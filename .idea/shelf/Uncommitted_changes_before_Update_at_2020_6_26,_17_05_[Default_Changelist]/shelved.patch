Index: src/com/fan/zuoalgorithm/ch01/Num11/Num11.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num11/Num11.java	(date 1593162277043)
+++ src/com/fan/zuoalgorithm/ch01/Num11/Num11.java	(date 1593162277043)
@@ -0,0 +1,21 @@
+package com.fan.zuoalgorithm.ch01.Num11;
+
+/**
+ * @author :  PF_23
+ * @Description : 可见的山峰对数量
+ * @date : 2019/11/10.
+ */
+
+public class Num11 {
+    public static int getVisibleNum(int[] arr) {
+        if (arr == null || arr.length < 2) {
+            return 0;
+        }
+        if (arr.length == 2) {
+            return 1;
+        }
+        return (arr.length << 1) - 3;
+
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num16.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num16.java	(date 1593162276805)
+++ src/com/fan/zuoalgorithm/cha04/Num16.java	(date 1593162276805)
@@ -0,0 +1,67 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 数字字符串转换为字母组合的种数
+ * @date : 2020/03/21.
+ */
+
+public class Num16 {
+    /**
+     * 暴力递归
+     *
+     * @param str
+     * @return
+     */
+    public int num1(String str) {
+        if (str == null || str.length() == 0) {
+            return 0;
+        }
+        char[] chars = str.toCharArray();
+        return process(chars, 0);
+    }
+
+    private int process(char[] chars, int i) {
+        if (i == chars.length - 1) {
+            return 1;
+        }
+        if (chars[i] == '0') {
+            return 0;
+        }
+        int res = process(chars, i + 1);
+        if (i + 1 < chars.length && (chars[i] - '0') * 10 + chars[i + 1] - '0' < 27) {
+            res += process(chars, i + 2);
+        }
+        return res;
+    }
+
+    /**
+     * 动态规划：类似斐波那契
+     *
+     * @param str
+     * @return
+     */
+    public int num2(String str) {
+        if (str == null || str.length() == 0) {
+            return 0;
+        }
+        char[] chars = str.toCharArray();
+        int cur = chars[chars.length - 1] == '0' ? 0 : 1;
+        int next = 1;
+        int tmp;
+        for (int i = chars.length - 1; i >= 0; i--) {
+            if (chars[i] == '0') {
+                next = cur;
+                cur = 0;
+            } else {
+                tmp = cur;
+                if ((chars[i] - '0') * 10 + chars[i + 1] - '0' < 27) {
+                    cur += next;
+                }
+                next = tmp;
+            }
+        }
+        return cur;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num05.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num05.java	(date 1593162277171)
+++ src/com/fan/zuoalgorithm/ch02/Num05.java	(date 1593162277171)
@@ -0,0 +1,80 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 反转部分单链表
+ * @date : 2019/11/18.
+ */
+
+public class Num05 {
+    public static Node reversePart(Node head, int from, int to) {
+        int len = 0;
+        Node node1 = head;
+        //获取反转起始节点的前一个节点
+        Node fPre = null;
+        //获取反转结束节点的后一个节点
+        Node tPos = null;
+
+        while (node1 != null) {
+            len++;
+            //找到反转起始节点的前一个节点
+            fPre = len == from - 1 ? node1 : fPre;
+            //找到反转结束节点的后一个节点
+            tPos = len == to + 1 ? node1 : tPos;
+            node1 = node1.next;
+        }
+        if (from > to || from < 1 || to > len) {
+            return head;
+        }
+        // node1 ： 反转链的起始点
+        node1 = fPre == null ? head : fPre.next;
+        Node node2 = node1.next;
+        //起始反转的节点指向反转结束节点的后一个节点
+        node1.next = tPos;
+        Node next;
+        // ************反转链表的核心代码********
+        while (node2 != tPos) {
+            next = node2.next;
+            node2.next = node1;
+            node1 = node2;
+            node2 = next;
+        }
+        // ***********************************
+        if (fPre != null) {
+            fPre.next = node1;
+            return head;
+        }
+        return node1;
+    }
+
+    //打印链表
+    public static void PrintList(Node head)
+    {
+        while(head!=null)
+        {
+
+            System.out.print(head.value+" ");
+            head=head.next;
+        }
+
+        System.out.println();
+
+    }
+    public static void main(String []args)
+    {
+
+        Node node=new Node(1);
+        node.next=new Node(2);
+        node.next.next=new Node(3);
+        node.next.next.next=new Node(4);
+        node.next.next.next.next=new Node(5);
+
+        System.out.println("反转部分链表前：");
+        PrintList(node);
+        //反转节点2---4
+        Node mode=reversePart(node,2,4);
+        System.out.println("反转部分链表后：");
+        PrintList(mode);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num14.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num14.java	(date 1593162277211)
+++ src/com/fan/zuoalgorithm/cha04/Num14.java	(date 1593162277211)
@@ -0,0 +1,97 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 字符串的交错组成
+ * @date : 2020/03/21.
+ */
+
+public class Num14 {
+    /**
+     * 金典动态规划
+     *
+     * @param str1
+     * @param str2
+     * @param aim
+     * @return
+     */
+    public boolean isCross1(String str1, String str2, String aim) {
+        if (str1 == null || str2 == null || aim == null) {
+            return false;
+        }
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        char[] chaim = aim.toCharArray();
+        // 如果长度和不等于chaim的长度
+        if (chs1.length + chs2.length != chaim.length) {
+            return false;
+        }
+        boolean[][] dp = new boolean[chs1.length + 1][chs2.length + 1];
+        // 初始化第一列
+        for (int i = 0; i < chs1.length; i++) {
+            // 如果aim[0..i - 1] == str1[0..i - 1]
+            if (chaim[i - 1] != chs1[i - 1]) {
+                break;
+            }
+            dp[i][0] = true;
+        }
+        // 初始化第一行
+        for (int i = 0; i < chs2.length; i++) {
+            // 如果aim[0..i - 1] == str2[0..i - 1]
+            if (chaim[i - 1] != chs2[i - 1]) {
+                break;
+            }
+            dp[0][i] = true;
+        }
+        for (int i = 1; i <= chs1.length; i++) {
+            for (int j = 1; j < chs2.length; j++) {
+                if (dp[i - 1][j] && (chs1[i - 1] == chaim[i + j - 1])) {
+                    dp[i][j] = true;
+                } else if (dp[i][j - 1] && (chs2[j - 1] == chaim[i + j - 1])) {
+                    dp[i][j] = true;
+                }
+            }
+        }
+        return dp[chs1.length][chs2.length];
+    }
+
+
+    /**
+     * 空间压缩 + 动态规划
+     *
+     * @param str1
+     * @param str2
+     * @param aim
+     * @return
+     */
+    public boolean isCross2(String str1, String str2, String aim) {
+        if (str1 == null || str2 == null || aim == null) {
+            return false;
+        }
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        char[] chaim = aim.toCharArray();
+        // 如果长度和不等于chaim的长度
+        if (chs1.length + chs2.length != chaim.length) {
+            return false;
+        }
+        char[] longs = chs1.length >= chs2.length ? chs1 : chs2;
+        char[] shorts = chs1.length < chs2.length ? chs1 : chs2;
+        boolean[] dp = new boolean[shorts.length + 1];
+        dp[0] = true;
+        for (int i = 1; i <= shorts.length; i++) {
+            dp[0] = dp[0] && longs[i - 1] == chaim[i - 1];
+            for (int j = 1; j <= longs.length; j++) {
+                if ((longs[i - 1] == chaim[j + i - 1]) && dp[j]) {
+                    dp[j] = true;
+                } else if ((shorts[j - 1] == chaim[i + j - 1] && dp[j - 1])) {
+                    dp[j] = true;
+                } else {
+                    dp[j] = false;
+                }
+            }
+        }
+        return dp[shorts.length];
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num13.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num13.java	(date 1593162276883)
+++ src/com/fan/zuoalgorithm/cha04/Num13.java	(date 1593162276883)
@@ -0,0 +1,87 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 最小编辑代价
+ * @date : 2020/03/21.
+ */
+
+public class Num13 {
+    public int minCost1(String str1, String str2, int ic, int dc, int rc) {
+        if (str1 == null || str2 == null) {
+            return 0;
+        }
+
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        int row = chs1.length + 1;
+        int col = chs2.length + 1;
+        // dp[i][j]的值代表str1[0..i - 1]编辑成str2[0..j-1]的最小代价
+        int[][] dp = new int[row][col];
+        for (int i = 1; i < row; i++) {
+            dp[i][0] = dc * i;
+        }
+        for (int i = 1; i < col; i++) {
+            dp[0][i] = ic * i;
+        }
+
+        for (int i = 1; i < row; i++) {
+            for (int j = 1; j < col; j++) {
+                if (chs1[i - 1] == chs2[j - 1]) {
+                    dp[i][j] = dp[i - 1][j - 1];
+                } else {
+                    // 替换的代价
+                    dp[i][j] = dp[i - 1][j - 1] + rc;
+                }
+                // 插入一个字符的代价
+                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);
+                // 删除一个字符的代价
+                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);
+            }
+        }
+        return dp[row - 1][col - 1];
+    }
+
+    public int minCost2(String str1, String str2, int ic, int dc, int rc) {
+        if (str1 == null || str2 == null) {
+            return 0;
+        }
+
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        char[] longs = chs1.length >= chs2.length ? chs1 : chs2;
+        char[] shorts = chs1.length < chs2.length ? chs1 : chs2;
+        if (chs1.length < chs2.length) {
+            // Str2较长就交换ic和dc的值
+            int tmp = ic;
+            ic = dc;
+            dc = tmp;
+        }
+        int[] dp = new int[shorts.length + 1];
+        for (int i = 1; i <= shorts.length; ++i) {
+            dp[i] = ic * i;
+        }
+        for (int i = 1; i < longs.length; i++) {
+            // pre表示左上角的值
+            int pre = dp[0];
+            dp[0] = dc * i;
+            for (int j = 1; j <= shorts.length; j++) {
+                // dp[j]没更新前先保存下来
+                int tmp = dp[j];
+                if (longs[i - 1] == shorts[j - 1]) {
+                    dp[j] = pre;
+                } else {
+                    dp[j] = pre + rc;
+                }
+                dp[j] = Math.min(dp[j], dp[j - 1] + ic);
+
+                dp[j] = Math.min(dp[j], tmp + dc);
+                // pre变成dp[j]没更新前的值
+                pre = tmp;
+            }
+        }
+        return dp[shorts.length];
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num20.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num20.java	(date 1593162276906)
+++ src/com/fan/zuoalgorithm/cha04/Num20.java	(date 1593162276906)
@@ -0,0 +1,48 @@
+package com.fan.zuoalgorithm.cha04;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author :  PF_23
+ * @Description : 数组中的最长连续序列
+ * @date : 2020/03/21.
+ */
+
+public class Num20 {
+    /**
+     * 利用哈希表实现
+     *
+     * @param arr
+     * @return
+     */
+    public int longestConsecutive(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+        int max = 0;
+        Map<Integer, Integer> map = new HashMap<>();
+        for (int i = 0; i < arr.length; i++) {
+            if (!map.containsKey(arr[i])) {
+                map.put(arr[i], 1);
+                if (map.containsKey(arr[i] - 1)) {
+                    max = Math.max(max, merge(map, arr[i] - 1, arr[i]));
+                }
+                if (map.containsKey(arr[i] + 1)) {
+                    max = Math.max(max, merge(map, arr[i], arr[i] + 1));
+                }
+            }
+        }
+        return max;
+    }
+
+    private int merge(Map<Integer, Integer> map, int less, int more) {
+        int left = less - map.get(less) + 1;
+        int right = more + map.get(more) - 1;
+        int len = right - left + 1;
+        map.put(right, len);
+        map.put(less, len);
+        return len;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num09.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num09.java	(date 1593162277093)
+++ src/com/fan/zuoalgorithm/ch02/Num09.java	(date 1593162277093)
@@ -0,0 +1,77 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.HashMap;
+
+/**
+ * @author :  PF_23
+ * @Description : 复制含有随机指针节点的链表
+ * @date : 2019/11/21.
+ */
+
+public class Num09 {
+    /**
+     * 普通解法：利用hash表
+     *
+     * @param head
+     * @return
+     */
+    public RanNode copyListWithRand1(RanNode head) {
+        HashMap<RanNode, RanNode> map = new HashMap<>();
+        RanNode cur = head;
+        while (cur != null) {
+            map.put(cur, new RanNode(cur.value));
+            cur = cur.next;
+        }
+        cur = head;
+        while (cur != null) {
+            map.get(cur).next = map.get(cur.next);
+            map.get(cur).rand = map.get(cur.rand);
+            cur = cur.next;
+        }
+        return map.get(head);
+    }
+
+    /**
+     * 进阶解法：先将每一个节点复制放在节点后面，然后设置每一个节点的随机节点，最后拆分链表，返回复制链表
+     *
+     * @param head 头结点
+     * @return 复制链表的头结点
+     */
+    public static RanNode copyListWithRand2(RanNode head) {
+        if (head == null) {
+            return null;
+        }
+        RanNode cur = head;
+        RanNode next = null;
+        // 复制并链接每一个节点
+        while (cur != null) {
+            next = cur.next;
+            cur.next = new RanNode(cur.value);
+            cur.next.next = next;
+            cur = next;
+        }
+        cur = head;
+        RanNode curCopy = null;
+        // 设置复制节点的rand指针
+        while (cur != null) {
+            next = cur.next.next;
+            curCopy = cur.next;
+            curCopy.rand = cur.rand != null ? cur.rand.next : null;
+            cur = next;
+        }
+        RanNode res = head.next;
+        cur = head;
+        // 拆分
+        while (cur != null) {
+            next = cur.next.next;
+            curCopy = cur.next;
+            cur.next = next;
+            curCopy.next = next != null ? next.next : null;
+            cur = next;
+        }
+        return res;
+    }
+
+
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num03.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num03.java	(date 1593162276955)
+++ src/com/fan/zuoalgorithm/ch02/Num03.java	(date 1593162276955)
@@ -0,0 +1,68 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 删除链表的中间节点和a/b处的节点
+ * @date : 2019/11/12.
+ */
+
+public class Num03 {
+
+    /**
+     * 删除中间节点
+     *
+     * @param head 头结点
+     * @return 删除中间节点后的链表头结点
+     */
+    public Node removeMidNode(Node head) {
+        if (head == null || head.next == null) {
+            return head;
+        }
+        if (head.next.next == null) {
+            return head.next;
+        }
+        Node slow = head;
+        Node fast = head;
+
+        while (fast.next != null && fast.next.next != null) {
+            slow = slow.next;
+            fast = fast.next.next;
+        }
+        slow.next = slow.next.next;
+        return head;
+    }
+
+    /**
+     * 删除a/b处的节点
+     *
+     * @param head 头结点
+     * @param a    a
+     * @param b    b
+     * @return 删除后的链表头结点
+     */
+    public Node removeByRatio(Node head, int a, int b) {
+        if (a < 1 || a > b) {
+            return head;
+        }
+        int n = 0;
+        Node cur = head;
+        while (cur != null) {
+            n++;
+            cur = cur.next;
+        }
+        n = (int) Math.ceil(((double) (a * n)) / (double) b);
+        if (n == 1) {
+            head = head.next;
+        }
+        if (n > 1) {
+            cur = head;
+            while (--n != 1) {
+                cur = cur.next;
+            }
+            cur.next = cur.next.next;
+        }
+        return head;
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num17.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num17.java	(date 1593162276784)
+++ src/com/fan/zuoalgorithm/ch02/Num17.java	(date 1593162276784)
@@ -0,0 +1,23 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 一种怪异的节点删除方式
+ * @date : 2019/12/03.
+ */
+
+public class Num17 {
+
+    public static void removeNodeWired(Node node) {
+        if (node == null) {
+            return;
+        }
+        Node next = node.next;
+        if (next == null) {
+            throw new RuntimeException("can not remove last node.");
+        }
+        node.value = next.value;
+        node.next = next.next;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Node.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Node.java	(date 1593162276960)
+++ src/com/fan/zuoalgorithm/ch02/Node.java	(date 1593162276960)
@@ -0,0 +1,22 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 链表
+ * @date : 2019/11/11.
+ */
+
+public class Node {
+    public int value;
+    public Node next;
+
+    public Node(int data) {
+        this.value = data;
+    }
+
+    @Override
+    public String toString() {
+        return super.toString();
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/num04/Cat.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/num04/Cat.java	(date 1593162277136)
+++ src/com/fan/zuoalgorithm/ch01/num04/Cat.java	(date 1593162277136)
@@ -0,0 +1,14 @@
+package com.fan.zuoalgorithm.ch01.num04;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/08.
+ */
+
+public class Cat extends Pet {
+    public Cat() {
+        super("cat");
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/RanNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/RanNode.java	(date 1593162276791)
+++ src/com/fan/zuoalgorithm/ch02/RanNode.java	(date 1593162276791)
@@ -0,0 +1,18 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/21.
+ */
+
+public class RanNode {
+    public int value;
+    public RanNode next;
+    public RanNode rand;
+
+    public RanNode(int data) {
+        this.value = data;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num09Plus.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num09Plus.java	(date 1593162276976)
+++ src/com/fan/zuoalgorithm/cha04/Num09Plus.java	(date 1593162276976)
@@ -0,0 +1,69 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 进阶问题
+ * @date : 2020/03/21.
+ */
+
+public class Num09Plus {
+    public int step1(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return -1;
+        }
+        return proess(arr, arr.length - 1, 1, 2, 3);
+    }
+
+    private int proess(int[] arr, int i, int from, int mid, int to) {
+        if (i == -1) {
+            return 0;
+        }
+        if (arr[i] != from && arr[i] != to) {
+            return -1;
+        }
+        // 第i个在from上面
+        if (arr[i] == from) {
+            return proess(arr, i - 1, from, to, mid);
+        } else {
+            // 第i个在to上面
+            int rest = proess(arr, i - 1, from, to, mid);
+            if (rest == -1) {
+                return -1;
+            }
+            return (1 << i) + rest;
+        }
+    }
+
+    /**
+     * 非递归方法
+     *
+     * @param arr
+     * @return
+     */
+    public int step2(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return -1;
+        }
+        int from = 1, mid = 2, to = 3;
+        int i = arr.length - 1;
+        int res = 0;
+        int tmp;
+        while (i >= 0) {
+            if (arr[i] != from && arr[i] != to) {
+                return -1;
+            }
+            if (arr[i] == from) {
+                tmp = to;
+                to = mid;
+            } else {
+                res += 1 << i;
+                tmp = from;
+                from = mid;
+            }
+            mid = tmp;
+            --i;
+        }
+        return res;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num03.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num03.java	(date 1593162277224)
+++ src/com/fan/zuoalgorithm/ch01/Num03.java	(date 1593162277224)
@@ -0,0 +1,68 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 如何仅用递归函数和桟操作逆序一个桟
+ * @date : 2019/11/03.
+ */
+
+public class Num03 {
+    /**
+     * 逆序桟
+     *
+     * @param stack stack
+     */
+    public static void reverse(Stack<Integer> stack) {
+        if (stack.isEmpty()) {
+            return;
+        }
+        int i = getAndRemoveLastElement(stack);
+        reverse(stack);
+        stack.push(i);
+    }
+
+    /**
+     * 返回桟底元素，并将其余元素压入原桟
+     *
+     * @param stack stack
+     * @return 桟底元素
+     */
+    public static int getAndRemoveLastElement(Stack<Integer> stack) {
+        int result = stack.pop();
+        if (stack.isEmpty()) {
+            return result;
+        } else {
+            int last = getAndRemoveLastElement(stack);
+            stack.push(result);
+            return last;
+        }
+    }
+
+    public static void main(String[] args) {
+        Stack<Integer> stack = new Stack<>();
+        stack.push(1);
+        stack.push(2);
+        stack.push(3);
+
+        System.out.println("反转桟之前：");
+        while (!stack.isEmpty()) {
+            int i = stack.pop();
+            System.out.print(i + "\t");
+        }
+        stack.push(1);
+        stack.push(2);
+        stack.push(3);
+        System.out.println();
+        System.out.println("============================");
+        System.out.println("反转桟之后：");
+        reverse(stack);
+        while (!stack.isEmpty()) {
+            int i = stack.pop();
+            System.out.print(i + "\t");
+        }
+        System.out.println();
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num10.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num10.java	(date 1593162277015)
+++ src/com/fan/zuoalgorithm/cha04/Num10.java	(date 1593162277015)
@@ -0,0 +1,63 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 最长公共子序列
+ * @date : 2020/03/21.
+ */
+
+public class Num10 {
+    // 1. 求出公共子序列的长度
+    // 2. 构建最长公共子序列
+
+    public int[][] getdp(char[] str1, char[] str2) {
+        int[][] dp = new int[str1.length][str2.length];
+        dp[0][0] = str1[0] == str2[0] ? 1 : 0;
+
+        // 初始化第1列
+        for (int i = 1; i < str1.length; i++) {
+            dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[i] ? 1 : 0);
+        }
+        // 初始化第1行
+        for (int i = 1; i < str2.length; i++) {
+            dp[0][i] = Math.max(dp[0][i - 1], str1[i] == str2[i] ? 1 : 0);
+        }
+        for (int i = 1; i < str1.length; i++) {
+            for (int j = 1; j < str2.length; j++) {
+                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
+                if (str1[i] == str2[j]) {
+                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
+                }
+            }
+        }
+        return dp;
+    }
+
+    public String lcse(String str1, String str2) {
+        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
+            return "";
+        }
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        int[][] dp = getdp(chs1, chs2);
+        int m = chs1.length - 1;
+        int n = chs2.length - 1;
+        // 最大公共长度
+        char[] res = new char[dp[m][n]];
+        int index = res.length - 1;
+        while (index >= 0) {
+            if (n > 0 && dp[m][n] == dp[m][n - 1]) {
+                n--;
+            } else if (m > 0 && dp[m][n] == dp[m - 1][n]) {
+                m--;
+            } else {
+                // dp[m][n] = dp[m - 1][n - 1] + 1（m,n处的字符相同）
+                res[index--] = chs1[m--];
+                n--;
+            }
+        }
+        return String.valueOf(res);
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num18.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num18.java	(date 1593162276776)
+++ src/com/fan/zuoalgorithm/ch02/Num18.java	(date 1593162276776)
@@ -0,0 +1,32 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 向有序的环形单链表中插入新节点
+ * @date : 2019/12/03.
+ */
+
+public class Num18 {
+
+    public static Node insertNum(Node head, int num) {
+        Node node = new Node(num);
+        if (head == null) {
+            node.next = node;
+            return node;
+        }
+
+        Node pre = head;
+        Node cur = head.next;
+        while (cur != null) {
+            if (pre.value < num && cur.value > num) {
+                break;
+            }
+            pre = cur;
+            cur = cur.next;
+        }
+        pre.next = node;
+        node.next = cur;
+        return head.value < num ? head : node;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch03/Node.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch03/Node.java	(date 1593162277083)
+++ src/com/fan/zuoalgorithm/ch03/Node.java	(date 1593162277083)
@@ -0,0 +1,18 @@
+package com.fan.zuoalgorithm.ch03;
+
+/**
+ * @author :  PF_23
+ * @Description : 二叉树定义
+ * @date : 2020/01/02.
+ */
+
+public class Node {
+    int value;
+    Node left;
+    Node right;
+
+    public Node(int data) {
+        this.value = data;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num06.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num06.java	(date 1593162276996)
+++ src/com/fan/zuoalgorithm/ch01/Num06.java	(date 1593162276996)
@@ -0,0 +1,112 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 用桟来求解汉诺塔问题
+ * @date : 2019/11/03.
+ */
+
+public class Num06 {
+
+    public static int hanoiProblem1(int num, String left, String mid, String right) {
+        if (num < 1) {
+            return 0;
+        }
+
+        return process(num, left, mid, right, left, right);
+    }
+
+    private static int process(int num, String left, String mid, String right, String from, String to) {
+        if (num == 1) {
+            if (from.equals(mid) || to.equals(mid)) {
+                System.out.println("Move 1 from " + from + " to " + to);
+                return 1;
+            } else {
+                System.out.println("Move 1 from " + from + " to " + mid);
+                System.out.println("Move 1 from " + mid + " to " + to);
+                return 2;
+            }
+        }
+
+        // 如果是从左到中移动
+        if (from.equals(mid) || to.equals(mid)) {
+            String another = (from.equals(left) || to.equals(left)) ? right : left;
+            // 将 1 ~ (num - 1)从左到右移动
+            int part1 = process(num - 1, left, mid, right, from, another);
+            // 将num从左到中移动
+            int part2 = 1;
+            System.out.println("Move " + num + " from " + from + " to " + to);
+            // 将1 ~ (num- 1) 从右到中移动
+            int part3 = process(num - 1, left, mid, right, another, to);
+            return part1 + part2 + part3;
+        } else {
+            // 将 1 ~ (num - 1)从左到右移动
+            int part1 = process(num - 1, left, mid, right, from, to);
+            // 将num从左到中移动
+            int part2 = 1;
+            System.out.println("Move " + num + " from " + from + " to " + mid);
+            // 将1 ~ (num- 1) 从右到左移动
+            int part3 = process(num - 1, left, mid, right, to, from);
+            //将num从中到右移动
+            int part4 = 1;
+            System.out.println("Move " + num + " from " + mid + " to " + to);
+            // 将 1 ~ (num - 1)从左到右移动
+            int part5 = process(num - 1, left, mid, right, from, to);
+            return part1 + part2 + part3 + part4 + part5;
+        }
+    }
+
+    public static void main(String[] args) {
+        int n = 3;
+        String left = "左";
+        String mid = "中";
+        String right = "右";
+        int steps = hanoiProblem1(n, left, mid, right);
+        System.out.println(steps);
+    }
+
+    // 方案二
+
+    public enum Action {
+        No, LToM, MToL, MToR, RToM
+    }
+
+    public int hanoiProblem2(int num, String left, String mid, String right) {
+        Stack<Integer> lS = new Stack<>();
+        Stack<Integer> mS = new Stack<>();
+        Stack<Integer> rS = new Stack<>();
+
+        lS.push(Integer.MAX_VALUE);
+        mS.push(Integer.MAX_VALUE);
+        rS.push(Integer.MAX_VALUE);
+
+        for (int i = num; i > 0; i--) {
+            lS.push(i);
+        }
+
+        Action[] record = {Action.No};
+        int step = 0;
+
+        while (rS.size() != num + 1) {
+            step += fStackTotStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);
+            step += fStackTotStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);
+            step += fStackTotStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);
+            step += fStackTotStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);
+        }
+        return step;
+    }
+
+    private int fStackTotStack(Action[] record, Action preNoAct, Action nowAct, Stack<Integer> fStack, Stack<Integer> tStack, String from, String to) {
+        if (record[0] != preNoAct && fStack.peek() < tStack.peek()) {
+            tStack.push(fStack.pop());
+            System.out.println("Move " + tStack.peek() + " from " + from + " to " + to);
+            record[0] = nowAct;
+            return 1;
+        }
+        return 0;
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num18.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num18.java	(date 1593162276909)
+++ src/com/fan/zuoalgorithm/cha04/Num18.java	(date 1593162276909)
@@ -0,0 +1,61 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 排成一条线的纸牌博弈问题
+ * @date : 2020/03/21.
+ */
+
+public class Num18 {
+    /**
+     * 暴力
+     *
+     * @param arr
+     * @return
+     */
+    public int win1(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+
+        return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));
+    }
+
+    private int f(int[] arr, int i, int j) {
+        if (i == j) {
+            return arr[i];
+        }
+        return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));
+    }
+
+    private int s(int[] arr, int i, int j) {
+        if (i == j) {
+            return arr[i];
+        }
+        return Math.max(arr[i] + f(arr, i + 1, j), arr[j] + f(arr, i, j - 1));
+    }
+
+    /**
+     * 动态规划
+     *
+     * @param arr
+     * @return
+     */
+    public int win2(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+        int[][] f = new int[arr.length][arr.length];
+        int[][] s = new int[arr.length][arr.length];
+
+        for (int j = 0; j < arr.length; j++) {
+            f[j][j] = arr[j];
+            for (int i = j - 1; i >= 0; i--) {
+                f[i][j] = Math.max(arr[i] + s[i + 1][j], arr[j] + s[i][j - 1]);
+                s[i][j] = Math.min(f[i + 1][j], f[i][j - 1]);
+            }
+        }
+        return Math.max(f[0][arr.length - 1], s[0][arr.length - 1]);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num01.java	(date 1593162277143)
+++ src/com/fan/zuoalgorithm/cha04/Num01.java	(date 1593162277143)
@@ -0,0 +1,65 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 斐波那契
+ * @date : 2020/03/20.
+ */
+
+public class Num01 {
+    /**
+     * O(2^N)
+     *
+     * @param n
+     * @return
+     */
+    public int f1(int n) {
+
+        if (n < 1) {
+            return 0;
+        }
+        if (n == 1 || n == 2) {
+            return 1;
+        }
+        return f1(n - 1) + f1(n - 2);
+    }
+
+    /**
+     * O(N)
+     *
+     * @param n
+     * @return
+     */
+    public int f2(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n == 1 || n == 2) {
+            return 1;
+        }
+        int p1 = 1;
+        int p2 = 1;
+        int res = 0;
+        for (int i = 3; i <= n; i++) {
+            res = p1 + p2;
+            p1 = p2;
+            p2 = res;
+        }
+        return res;
+    }
+
+    public int f3(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n == 1 || n == 2) {
+            return 1;
+        }
+        int[][] base = {{1, 1}, {1, 0}};
+        int[][] res = MatrixPowerUtil.matrixPower(base, n - 2);
+        return res[0][0] + res[0][1];
+    }
+
+
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num10.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num10.java	(date 1593162276964)
+++ src/com/fan/zuoalgorithm/ch01/Num10.java	(date 1593162276964)
@@ -0,0 +1,61 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.LinkedList;
+
+/**
+ * @author :  PF_23
+ * @Description : 最大值减去最小值小于或等于num的子数组数量
+ * @date : 2019/11/07.
+ */
+
+public class Num10 {
+    public static int getNum(int[] arr, int num) {
+        if (arr == null || arr.length == 0 || num < 0) {
+            return 0;
+        }
+        LinkedList<Integer> qMin = new LinkedList<>();
+        LinkedList<Integer> qMax = new LinkedList<>();
+        int i = 0, j = 0;
+        int res = 0;
+        while (i < arr.length) {
+            while (j < arr.length) {
+                if (qMin.isEmpty() || arr[qMin.peekLast()] != j) {
+                    // 维护一个自底向上的递增双端队列 qMin.peekLast()是qMin双端队列中最大的值
+                    while (!qMin.isEmpty() && arr[qMin.peekLast()] >= arr[j]) {
+                        qMin.pollLast();
+                    }
+                    qMin.addLast(j);
+                    // 维护一个自底向上的递双端队列 qMax.peekLast()是qMax双端队列中最小的值
+                    while (!qMax.isEmpty() && arr[qMax.peekLast()] <= arr[j]) {
+                        qMax.pollLast();
+                    }
+                    qMax.addLast(j);
+                }
+                if (arr[qMax.getFirst()] - arr[qMin.getFirst()] > num) {
+                    break;
+                }
+                j++;
+            }
+            res += j - i;
+            // 跟新最小值：因为i++
+            if (qMin.peekFirst() == i) {
+                qMin.pollFirst();
+            }
+            // 跟新最大值：因为i++
+            if (qMax.peekFirst() == i) {
+                qMax.pollFirst();
+            }
+            i++;
+        }
+        return res;
+    }
+
+    public static void main(String[] args) {
+        int[] arr = {3, 4, 3, 5, 6, 4, 5, 7};
+        int num = 3;
+        int res = getNum(arr, num);
+        System.out.println(res);
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch01/num04/PetEnterQueue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/num04/PetEnterQueue.java	(date 1593162277062)
+++ src/com/fan/zuoalgorithm/ch01/num04/PetEnterQueue.java	(date 1593162277062)
@@ -0,0 +1,30 @@
+package com.fan.zuoalgorithm.ch01.num04;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/08.
+ */
+
+public class PetEnterQueue {
+    private Pet pet;
+    private long count;
+
+    public PetEnterQueue(Pet pet, long count) {
+        this.pet = pet;
+        this.count = count;
+    }
+
+    public Pet getPet() {
+        return this.pet;
+    }
+
+    public long getCount() {
+        return this.count;
+    }
+
+    public String getEnterType() {
+        return this.pet.getPetType();
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num17.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num17.java	(date 1593162276893)
+++ src/com/fan/zuoalgorithm/cha04/Num17.java	(date 1593162276893)
@@ -0,0 +1,145 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 表达式得到期望结果的组成种数
+ * @date : 2020/03/21.
+ */
+
+public class Num17 {
+
+    public boolean isValid(char[] exp) {
+        int len = exp.length;
+        // 表达式的长度必须是奇数
+        if (len % 2 == 0) {
+            return false;
+        }
+        // 表达式下表为偶数位置的字符一定是'0'或者'1'
+        for (int i = 0; i < len; i += 2) {
+            if (exp[i] != '1' && exp[i] != '0') {
+                return false;
+            }
+        }
+
+        // 表达式下表为奇数位置的字符一定是'&'或者'|' '^'
+        for (int i = 1; i < len; i += 2) {
+            if (exp[i] != '&' && exp[i] != '|' && exp[i] != '^') {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public int num1(String express, boolean desired) {
+        if (express == null || express.length() == 0) {
+            return 0;
+        }
+        char[] exp = express.toCharArray();
+        if (!isValid(exp)) {
+            return 0;
+        }
+        return p(exp, desired, 0, exp.length - 1);
+    }
+
+    /**
+     * 暴力递归
+     *
+     * @param exp
+     * @param desired
+     * @param l
+     * @param r
+     * @return
+     */
+    private int p(char[] exp, boolean desired, int l, int r) {
+        if (l == r) {
+            if (exp[l] == '1') {
+                return desired ? 1 : 0;
+            } else {
+                return desired ? 0 : 1;
+            }
+        }
+
+        int res = 0;
+        // true
+        if (desired) {
+            for (int i = l + 1; i < r; i += 2) {
+                switch (exp[i]) {
+                    case '&':
+                        res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r);
+                        break;
+                    case '|':
+                        res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r);
+                        res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r);
+                        res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r);
+                        break;
+                    case '^':
+                        res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r);
+                        res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r);
+                        break;
+
+                }
+            }
+        } else {
+            // false
+            for (int i = l + 1; i < r; i += 2) {
+                switch (exp[i]) {
+                    case '&':
+                        res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r);
+                        res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r);
+                        res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r);
+                        break;
+                    case '|':
+                        res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r);
+                        break;
+                    case '^':
+                        res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r);
+                        res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r);
+                        break;
+
+                }
+            }
+        }
+        return res;
+    }
+
+
+    public int num2(String express, boolean desired) {
+        if (express == null || express.length() == 0) {
+            return 0;
+        }
+        char[] exp = express.toCharArray();
+        if (!isValid(exp)) {
+            return 0;
+        }
+
+        int[][] t = new int[exp.length][exp.length];
+        int[][] f = new int[exp.length][exp.length];
+
+        t[0][0] = exp[0] == '0' ? 0 : 1;
+        f[0][0] = exp[0] == '1' ? 0 : 1;
+
+        for (int i = 2; i < exp.length; i += 2) {
+            t[i][i] = exp[i] == '0' ? 0 : 1;
+            t[i][i] = exp[i] == '1' ? 0 : 1;
+
+            for (int j = i - 2; j >= 0; j -= 2) {
+                for (int k = j; k < i; k += 2) {
+                    if (exp[k + 1] == '&') {
+                        t[j][i] += t[j][k] * t[k + 2][i];
+                        f[j][i] += (f[j][k] + t[j][k]) * f[k + 2][i] + f[j][k] * t[k + 2][i];
+                    } else if (exp[k + 1] == '|') {
+                        t[j][i] += (f[j][k] + t[j][k]) * t[k + 2][i] + t[j][k] * f[k + 2][i];
+                        f[j][i] += f[j][k] * f[k + 2][i];
+                    } else {
+                        t[j][i] += f[j][k] * t[k + 2][i] + t[j][k] * f[k + 2][i];
+                        f[j][i] += f[j][k] * f[k + 2][i] + t[j][k] * t[k + 2][i];
+                    }
+                }
+            }
+        }
+        return desired ? t[0][exp.length - 1] : f[0][exp.length - 1];
+    }
+
+
+}
+
Index: src/com/fan/zuoalgorithm/cha04/MatrixPowerUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/MatrixPowerUtil.java	(date 1593162276780)
+++ src/com/fan/zuoalgorithm/cha04/MatrixPowerUtil.java	(date 1593162276780)
@@ -0,0 +1,61 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 求矩阵的幂积
+ * @date : 2020/03/21.
+ */
+
+public class MatrixPowerUtil {
+
+    /**
+     * 矩阵m的p次方
+     *
+     * @param m
+     * @param p
+     * @return
+     */
+    public static int[][] matrixPower(int[][] m, int p) {
+        int[][] res = new int[m.length][m[0].length];
+        // 先把res设置为单位矩阵，相当于整数中的1
+        for (int i = 0; i < res.length; i++) {
+            /**
+             *  1 0
+             *  0 1
+             */
+            res[i][i] = 1;
+        }
+        int[][] tmp = m;
+        for (; p != 0; p >>= 1) {
+            // 当当前二进制的位 == 1时，累乘
+            if ((p & 1) != 0) {
+                res = multiMatrix(res, tmp);
+            }
+            tmp = multiMatrix(tmp, tmp);
+        }
+        return res;
+    }
+
+    /**
+     * 求矩阵m1和m2的乘积
+     *
+     * @param m1
+     * @param m2
+     * @return
+     */
+    public static int[][] multiMatrix(int[][] m1, int[][] m2) {
+        int[][] res = new int[m1.length][m2[0].length];
+        for (int i = 0; i < m1.length; i++) {
+            for (int j = 0; j < m2[0].length; j++) {
+                for (int k = 0; k < m2.length; k++) {
+                    res[i][j] += m1[i][k] * m2[k][j];
+                }
+            }
+
+        }
+        return res;
+    }
+
+
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num08Plus.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num08Plus.java	(date 1593162276912)
+++ src/com/fan/zuoalgorithm/ch01/Num08Plus.java	(date 1593162276912)
@@ -0,0 +1,53 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 相对于上一题，本题加入条件 有重复元素的时候 ，依然返回左右两边最近且比自己小的元素位置
+ * @date : 2019/11/06.
+ */
+
+public class Num08Plus {
+    public static int[][] getNearLessNoRepeat(int[] arr) {
+        int[][] res = new int[arr.length][2];
+        Stack<List<Integer>> stack = new Stack<>();
+
+        for (int i = 0; i < arr.length; i++) {
+            while (!stack.isEmpty() && arr[i] < arr[stack.peek().get(0)]) {
+                List<Integer> popIndexs = stack.pop();
+                // 取位于下面位置的列表中，最晚加入的那一个
+                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
+
+                for (Integer popIndex : popIndexs) {
+                    res[popIndex][0] = leftLessIndex;
+                    res[popIndex][1] = i;
+                }
+            }
+            // 元素arr[i] == arr[stack.peek().get(0)]元素
+            if (!stack.isEmpty() && arr[i] == arr[stack.peek().get(0)]) {
+                stack.peek().add(Integer.valueOf(i));
+            } else { // arr[i] > arr[stack.peek().get(0)],则新增一个集合，然后压入栈顶
+                ArrayList<Integer> list = new ArrayList<>();
+                list.add(i);
+                stack.push(list);
+            }
+        }
+
+        while (!stack.isEmpty()) {
+            List<Integer> popIndexs = stack.pop();
+            // 取位于下面位置的列表中，最晚加入的那一个
+            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
+
+            for (Integer popIndex : popIndexs) {
+                res[popIndex][0] = leftLessIndex;
+                res[popIndex][1] = -1;
+            }
+        }
+        return res;
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num03.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num03.java	(date 1593162276938)
+++ src/com/fan/zuoalgorithm/cha04/Num03.java	(date 1593162276938)
@@ -0,0 +1,89 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 还钱的最少货币数
+ * @date : 2020/03/21.
+ */
+
+public class Num03 {
+    /**
+     * 暴力递归
+     *
+     * @param arr
+     * @param aim
+     * @return
+     */
+    public int minCoins1(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return -1;
+        }
+        return process(arr, 0, aim);
+    }
+
+    /**
+     * 当前考虑的面值是arr[i],还剩rest的钱需要找零
+     * 如果返回-1，说明自由使用arr[i .. N- 1]面值的情况下，无论如何也如法找零rest
+     * 如果返回不是-1，代表自由使用arr[i .. N- 1]面值的情况下，找零rest需要的最少张数
+     *
+     * @param arr
+     * @param i
+     * @param rest
+     * @return
+     */
+    private int process(int[] arr, int i, int rest) {
+        if (i == arr.length) {
+            return rest == 0 ? 0 : -1;
+        }
+
+        // 最少张数，初始值为-1， 因为还没有找到有效解
+        int res = -1;
+
+        for (int j = 0; j * arr[i] <= rest; j++) {
+            int next = process(arr, i + 1, rest - j * arr[i]);
+            if (next != -1) {
+                // 说明后续过程有效
+                res = res == -1 ? next + j : Math.min(res, next + j);
+            }
+        }
+        return res;
+    }
+
+    public int minCoins2(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return -1;
+        }
+        int N = arr.length;
+        // 表示在还剩N个面值硬币的情况下找零aim的最少数值
+        int[][] dp = new int[N + 1][aim + 1];
+        // 设置最后一排的值
+        for (int col = 1; col <= aim; col++) {
+            dp[N][col] = -1;
+        }
+        // 从低往上计算每一行
+        for (int i = N - 1; i >= 0; i--) {
+            // 每一行都从左到右
+            for (int rest = 0; rest <= aim; rest++) {
+                // 初始时先设置dp[i][rest]的值无效
+                dp[i][rest] = -1;
+                if (dp[i + 1][rest] != -1) {
+                    // 下面的值如果有效，先设置成下面的值
+                    dp[i][rest] = dp[i + 1][rest];
+                }
+                // 如果左边的值不越界且有效
+                if (rest - arr[i] >= 0 && dp[i][rest - arr[i]] != -1) {
+                    // 如果之前下面的值无效
+                    if (dp[i][rest] == -1) {
+                        // 设置为左边的值
+                        dp[i][rest] = dp[i][rest - arr[i]];
+                    } else {
+                        // 否则，去下面和左边的最小值
+                        dp[i][rest] = Math.min(dp[i + 1][rest], dp[i][rest - arr[i]]);
+                    }
+                }
+            }
+        }
+        return dp[0][aim];
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num11/Record.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num11/Record.java	(date 1593162277261)
+++ src/com/fan/zuoalgorithm/ch01/Num11/Record.java	(date 1593162277261)
@@ -0,0 +1,18 @@
+package com.fan.zuoalgorithm.ch01.Num11;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/10.
+ */
+
+public class Record {
+    public int value;
+    public int times;
+
+    public Record(int value) {
+        this.value = value;
+        this.times = 1;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num15.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num15.java	(date 1593162277008)
+++ src/com/fan/zuoalgorithm/ch02/Num15.java	(date 1593162277008)
@@ -0,0 +1,100 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.LinkedList;
+import java.util.Queue;
+
+/**
+ * @author :  PF_23
+ * @Description : 将二叉搜索树转换成双向链表
+ * 其实就是中序遍历
+ * @date : 2019/12/03.
+ */
+
+public class Num15 {
+    /**
+     * 方法一：中序遍历   利用队列
+     *
+     * @param head 头结点
+     * @return
+     */
+    public DNode convert1(DNode head) {
+        Queue<DNode> queue = new LinkedList<>();
+        inOrderToQueue(head, queue);
+        if (queue.isEmpty()) {
+            return head;
+        }
+        head = queue.poll();
+        DNode pre = head;
+        pre.left = null;
+        DNode cur;
+        while (!queue.isEmpty()) {
+            cur = queue.poll();
+            pre.right = cur;
+            cur.left = pre;
+            pre = cur;
+        }
+        pre.right = null;
+        return head;
+    }
+
+    private void inOrderToQueue(DNode head, Queue<DNode> queue) {
+        if (head == null) {
+            return;
+        }
+        inOrderToQueue(head.left, queue);
+        queue.offer(head);
+        inOrderToQueue(head.right, queue);
+    }
+
+    /**
+     * 方法二： 通过递归函数返回自定义数据结构
+     * @param head
+     * @return
+     */
+    public DNode convert2(DNode head) {
+        if (head == null) {
+            return null;
+        }
+        return process(head).start;
+    }
+
+    public ReturnTye process(DNode head) {
+        if (head == null) {
+            return new ReturnTye(null, null);
+        }
+        ReturnTye leftList = process(head.left);
+        ReturnTye rightList = process(head.right);
+        if (leftList.end != null) {
+            leftList.end.right = head;
+        }
+        head.left = leftList.end;
+        head.right = rightList.start;
+        if (rightList.start != null) {
+            rightList.start.left = head;
+        }
+        return new ReturnTye(leftList.start != null ? leftList.start : head,
+                rightList.end != null ? rightList.end : head);
+    }
+
+    class DNode {
+        private int value;
+        private DNode left;
+        private DNode right;
+
+        DNode(int data) {
+            this.value = data;
+        }
+    }
+
+    class ReturnTye {
+        public DNode start;
+        public DNode end;
+
+        public ReturnTye(DNode start, DNode end) {
+            this.start = start;
+            this.end = end;
+        }
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num07.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num07.java	(date 1593162276900)
+++ src/com/fan/zuoalgorithm/ch01/Num07.java	(date 1593162276900)
@@ -0,0 +1,48 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Arrays;
+import java.util.LinkedList;
+
+/**
+ * @author :  PF_23
+ * @Description : 生成窗口最大值数组
+ * @date : 2019/11/04.
+ */
+
+public class Num07 {
+
+    public static int[] getMaxWindow(int[] arr, int w) {
+        if (arr == null || w < 1 || arr.length < w) {
+            return null;
+        }
+
+        // 维护一个递减的双端队列：队头元素为最大值
+        LinkedList<Integer> qMax = new LinkedList<>();
+        int[] res = new int[arr.length - w + 1];
+        int index = 0;
+        for (int i = 0; i < arr.length; i++) {
+            while (!qMax.isEmpty() && arr[qMax.peekLast()] <= arr[i]) {
+                qMax.pollLast();
+            }
+            qMax.addLast(i);
+            // 队头过期
+            if (qMax.peekFirst() == (i - w)) {
+                qMax.pollFirst();
+            }
+            // 每次滑动都会有结果出现
+            if (i >= w - 1) {
+                res[index++] = arr[qMax.peekFirst()];
+            }
+        }
+        return res;
+    }
+
+    public static void main(String[] args) {
+//        Num07 num07 = new Num07();
+        int[] arr = {4,3,5,4,3,3,6,7};
+        int w = 3;
+        int[] maxWindow = getMaxWindow(arr, w);
+        System.out.println(Arrays.toString(maxWindow));
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/DoubleNode.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/DoubleNode.java	(date 1593162276967)
+++ src/com/fan/zuoalgorithm/ch02/DoubleNode.java	(date 1593162276967)
@@ -0,0 +1,18 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/11.
+ */
+
+public class DoubleNode {
+    public int value;
+    public DoubleNode last;
+    public DoubleNode next;
+
+    public DoubleNode(int data) {
+        this.value = data;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num11.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num11.java	(date 1593162276795)
+++ src/com/fan/zuoalgorithm/ch02/Num11.java	(date 1593162276795)
@@ -0,0 +1,148 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 两个单链表相交的一系列问题
+ * @date : 2019/11/21.
+ */
+
+public class Num11 {
+
+    /**
+     * 主方法
+     *
+     * @param head1 头1
+     * @param head2 头2
+     * @return 第一个交点
+     */
+    public static Node getIntersectNode(Node head1, Node head2) {
+        if (head1 == null || head2 == null) {
+            return null;
+        }
+        Node loop1 = getLoopNode(head1);
+        Node loop2 = getLoopNode(head2);
+        if (loop1 == null && loop2 == null) {
+            return noLoop(head1, head2);
+        }
+        if (loop1 != null && loop2 != null) {
+            return bothLoop(head1, loop1, head2, loop2);
+        }
+        return null;
+    }
+
+    /**
+     * 问题一：判断链表是否有环，有则返回入口，无则返回null
+     *
+     * @param head
+     * @return
+     */
+    public static Node getLoopNode(Node head) {
+        if (head == null || head.next == null || head.next.next == null) {
+            return null;
+        }
+
+        Node fast = head.next.next;
+        Node slow = head.next;
+        while (fast != slow) {
+            if (fast.next == null || fast.next.next == null) {
+                return null;
+            }
+            fast = fast.next.next;
+            slow = slow.next;
+        }
+        fast = head;
+        while (fast != slow) {
+            fast = fast.next;
+            slow = slow.next;
+        }
+        return slow;
+    }
+
+    /**
+     * 问题二：判断两个无环链表是否相交
+     *
+     * @param head1 头1
+     * @param head2 头2
+     * @return 第一个交点
+     */
+    public static Node noLoop(Node head1, Node head2) {
+        if (head1 == null || head2 == null) {
+            return null;
+        }
+        int n = 0;
+        Node cur1 = head1;
+        Node cur2 = head2;
+        while (cur1.next != null) {
+            n++;
+            cur1 = cur1.next;
+        }
+        while (cur2.next != null) {
+            --n;
+            cur2 = cur2.next;
+        }
+        if (cur1 != cur2) {
+            return null;
+        }
+        cur1 = n > 0 ? head1 : head2;
+        cur2 = cur1 == head1 ? head2 : head1;
+        n = Math.abs(n);
+        while (n != 0) {
+            n--;
+            cur1 = cur1.next;
+        }
+        while (cur1 != cur2) {
+            cur1 = cur1.next;
+            cur2 = cur2.next;
+        }
+        return cur1;
+    }
+
+    /**
+     * 问题三：判断两个有环链表是否相交，不想交返回null；相交则返回交点：当在入环前相交时，返回第一个交点；否则返回两个入环点中的任意一个
+     *
+     * @param head1 头1
+     * @param loop1 入环点1
+     * @param head2 头2
+     * @param loop2 入环点2
+     * @return
+     */
+    public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
+        Node cur1 = null;
+        Node cur2 = null;
+        if (loop1 == loop2) {
+            cur1 = head1;
+            cur2 = head2;
+            int n = 0;
+            while (cur1 != loop1) {
+                n++;
+                cur1 = cur1.next;
+            }
+            while (cur2 != loop2) {
+                n--;
+                cur2 = cur2.next;
+            }
+            cur1 = n > 0 ? head1 : head2;
+            cur2 = cur1 == head1 ? head2 : head1;
+            n = Math.abs(n);
+            while (n != 0) {
+                n--;
+                cur1 = cur1.next;
+            }
+            while (cur1 != cur2) {
+                cur1 = cur1.next;
+                cur2 = cur2.next;
+            }
+            return cur1;
+        } else {
+            cur1 = loop1.next;
+            while (cur1 != loop1) {
+                if (cur1 == loop2) {
+                    return loop1;
+                }
+                cur1 = cur1.next;
+            }
+            return null;
+        }
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num07.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num07.java	(date 1593162276925)
+++ src/com/fan/zuoalgorithm/ch02/Num07.java	(date 1593162276925)
@@ -0,0 +1,136 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 判断链表是否是回文结构
+ * @date : 2019/11/19.
+ */
+
+public class Num07 {
+    public static boolean isPalindrome1(Node head) {
+        if (head == null || head.next == null) {
+            return true;
+        }
+        Stack<Node> stack = new Stack<>();
+        Node cur = head;
+        while (cur != null) {
+            stack.push(cur);
+            cur = cur.next;
+        }
+        while (head != null) {
+            if (head.value != stack.pop().value) {
+                return false;
+            }
+            head = head.next;
+        }
+        return true;
+    }
+
+    /**
+     * 方法二:只将链表的右半区压入桟中
+     *
+     * @param head
+     * @return
+     */
+    public static boolean isPalindrome2(Node head) {
+        if (head == null || head.next == null) {
+            return true;
+        }
+        Node right = head.next;
+        Node cur = head;
+        while (cur.next != null && cur.next.next != null) {
+            right = right.next;
+            cur = cur.next.next;
+        }
+        Stack<Node> stack = new Stack<>();
+        while (right != null) {
+            stack.push(right);
+            right = right.next;
+        }
+        while (!stack.isEmpty()) {
+            if (head.value != stack.pop().value) {
+                return false;
+            }
+            head = head.next;
+        }
+        return true;
+    }
+
+    // 方法三 进阶
+    public static boolean isPalindrome3(Node head) {
+        if (head == null || head.next == null) {
+            return true;
+        }
+        Node n1 = head;
+        Node n2 = head;
+        // 为了求出中部遍历n2 ： 快慢指针法
+        while (n2.next != null && n2.next.next != null) {
+            // n1 -> 中部
+            n1 = n1.next;
+            // n2 -> 结尾
+            n2 = n2.next.next;
+        }
+        // n2 -> 右部分第一个节点
+        n2 = n1.next;
+        // mid.next -> null
+        n1.next = null;
+        Node n3;
+        // 反转又半区
+        while (n2 != null) {
+            // n3保存下一个节点
+            n3 = n2.next;
+            // 反转
+            n2.next = n1;
+            //n1右移
+            n1 = n2;
+            // n2右移
+            n2 = n3;
+        }
+        // n3保存尾节点
+        n3 = n1;
+        // n2保存头结点
+        n2 = head;
+        boolean res = true;
+        // 检查回文
+        while (n1 != null && n2 != null) {
+            if (n1.value != n2.value) {
+                res = false;
+                break;
+            }
+            // 从左到中部
+            n1 = n1.next;
+            // 从右到中部
+            n2 = n2.next;
+
+        }
+        n1 = n3.next;
+        n3.next = null;
+        // 恢复链表
+        while (n1 != null) {
+            n2 = n1.next;
+            n1.next = n3;
+            n3 = n1;
+            n1 = n2;
+        }
+        return res;
+    }
+
+    public static void main(String[] args) {
+        Node node = new Node(1);
+        Node node2 = new Node(2);
+        Node node3 = new Node(3);
+        Node node4 = new Node(2);
+        Node node5 = new Node(1);
+        node.next = node2;
+        node2.next = node3;
+        node3.next = node4;
+        node4.next = node5;
+        node5.next = null;
+
+        boolean palindrome3 = isPalindrome3(node);
+        System.out.println(palindrome3);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num06.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num06.java	(date 1593162276889)
+++ src/com/fan/zuoalgorithm/ch02/Num06.java	(date 1593162276889)
@@ -0,0 +1,32 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 约瑟夫环
+ * @date : 2019/11/18.
+ */
+
+public class Num06 {
+
+    public static Node josephusKill(Node head, int m) {
+        if (head == null || head.next == head || m < 1) {
+            return head;
+        }
+        int count = 0;
+        Node last = head;
+        while (last.next != head) {
+            last = last.next;
+        }
+        while (last != head) {
+            if (++count == m) {
+                last.next = head.next;
+                count = 0;
+            } else {
+                last = last.next;
+            }
+            head = last.next;
+        }
+        return head;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num19.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num19.java	(date 1593162276810)
+++ src/com/fan/zuoalgorithm/ch02/Num19.java	(date 1593162276810)
@@ -0,0 +1,38 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 合并两个有序链表
+ * @date : 2019/12/03.
+ */
+
+public class Num19 {
+
+    public static Node merge(Node head1, Node head2) {
+        if (head1 == null || head2 == null) {
+            return head1 == null ? head2 : head1;
+        }
+
+        Node head = head1.value < head2.value ? head1 : head2;
+        Node cur1 = head == head1 ? head1 : head2;
+        Node cur2 = head == head1 ? head2 : head1;
+        Node pre = null;
+        Node next;
+        while (cur1 != null && cur2 != null) {
+            if (cur1.value <= cur2.value) {
+                pre = cur1;
+                cur1 = cur1.next;
+            } else {
+                next = cur2.next;
+                pre.next = cur2;
+                cur2.next = cur1;
+                pre = cur2;
+                cur2 = next;
+            }
+        }
+
+        pre.next = cur1 == null ? cur2 : cur1;
+        return head;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num02.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num02.java	(date 1593162277245)
+++ src/com/fan/zuoalgorithm/cha04/Num02.java	(date 1593162277245)
@@ -0,0 +1,88 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 矩阵的最小路径和
+ * @date : 2020/03/21.
+ */
+
+public class Num02 {
+
+    public int minPathSum1(int[][] matrix) {
+        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
+            return 0;
+        }
+        int row = matrix.length;
+        int col = matrix[0].length;
+        // dp[i][j]表示从（0，0） 到（i, j）位置的最小路径
+        int[][] dp = new int[row][col];
+        dp[0][0] = matrix[0][0];
+        // 第一列只能从上到下
+//        for (int i = 1; i < row; i++) {
+//            dp[0][i] += matrix[0][i];
+//        }
+//
+//        // 第一行只能从左到右
+//        for (int i = 1; i < col; i++) {
+//            dp[i][0] += matrix[i][0];
+//        }
+
+        // 第一列只能从上到下
+        for (int i = 1; i < row; i++) {
+            dp[0][i] = dp[0][i - 1] + matrix[0][i];
+        }
+
+        // 第一行只能从左到右
+        for (int i = 1; i < col; i++) {
+            dp[i][0] += dp[i - 1][0] + matrix[i][0];
+        }
+
+        for (int i = 1; i < row; i++) {
+            for (int j = 1; j < col; j++) {
+                // 两种到达路径的最小值
+                dp[i][j] = Math.min(dp[i][j], Math.min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]);
+            }
+        }
+        return dp[row - 1][col - 1];
+    }
+
+    /**
+     * 空间压缩技巧
+     *
+     * @param matrix
+     * @return
+     */
+    public int minPathSum2(int[][] matrix) {
+        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
+            return 0;
+        }
+        // more是行数和列数中更大的那个
+        int more = Math.max(matrix.length, matrix[0].length);
+        // less是行数和列数更小的那个
+        int less = Math.min(matrix.length, matrix[0].length);
+        // 行数是不是大于等于列数
+        boolean rowmore = more == matrix.length;
+        // 数组长度仅为行数和列数更小的那个 （空间压缩策略）
+        int[] arr = new int[less];
+        arr[0] = matrix[0][0];
+        // 根据行数和列数谁更大更新第一行或者第一列的最小路径
+        for (int i = 1; i < less; i++) {
+            arr[i] = arr[i - 1] + (rowmore ? matrix[0][i] : matrix[i][0]);
+        }
+        // 滚动更新每行或者每列的最小路径值
+        for (int i = 1; i < more; i++) {
+            arr[0] = arr[0] + (rowmore ? matrix[i][0] : matrix[0][i]);
+            for (int j = 1; j < less; j++) {
+                arr[j] = Math.min(arr[j - 1], arr[j]) + (rowmore ? matrix[i][j] : matrix[j][i]);
+            }
+        }
+        return arr[less - 1];
+    }
+
+    public static void main(String[] args) {
+        int[][] matrix = {{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0}};
+        int pathSum2 = new Num02().minPathSum2(matrix);
+        System.out.println(pathSum2);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num06Plus.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num06Plus.java	(date 1593162277003)
+++ src/com/fan/zuoalgorithm/ch02/Num06Plus.java	(date 1593162277003)
@@ -0,0 +1,40 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 时间复杂度为O(N)
+ * @date : 2019/11/18.
+ */
+
+public class Num06Plus {
+    public static Node josephusKill(Node head, int m) {
+        if (head == null || head.next == null || m < 1) {
+            return head;
+        }
+
+        int tmp = 1;
+        Node cur = head.next;
+        // 计数
+        while (cur != head) {
+            tmp++;
+            cur = cur.next;
+        }
+        // 得到最后剩下的节点编码（老编码）
+        tmp = getLive(tmp, m);
+        while (--tmp != 0) {
+            head = head.next;
+        }
+        // 只保留自己，其他节点不要
+        head.next = head;
+        return head;
+    }
+
+    private static int getLive(int i, int m) {
+        if (i == 1) {
+            return 1;
+        }
+        return (getLive(i - 1, m) + m - 1) % i + 1;
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num09Plus.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num09Plus.java	(date 1593162276829)
+++ src/com/fan/zuoalgorithm/ch01/Num09Plus.java	(date 1593162276829)
@@ -0,0 +1,44 @@
+package com.fan.zuoalgorithm.ch01;
+
+/**
+ * @author :  PF_23
+ * @Description : 接雨水 LeetCode42
+ * @date : 2019/11/08.
+ */
+
+public class Num09Plus {
+    /**
+     * 双指针法
+     *
+     * @param height 📊柱状图
+     * @return 雨滴数
+     */
+    public static int trap(int[] height) {
+        if (height == null || height.length == 0) {
+            return 0;
+        }
+        int left = 0, right = height.length - 1;
+        int res = 0;
+        int leftMax = 0, rightMax = 0;
+
+        while (left < right) {
+            if (height[left] < height[right]) {
+                if (height[left] >= leftMax) {
+                    leftMax = height[left];
+                } else {
+                    res += leftMax - height[left];
+                }
+                left++;
+            } else {
+                if (height[right] >= rightMax) {
+                    rightMax = height[right];
+                } else {
+                    res += rightMax - height[right];
+                }
+                right--;
+            }
+        }
+        return res;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/num04/Dog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/num04/Dog.java	(date 1593162276942)
+++ src/com/fan/zuoalgorithm/ch01/num04/Dog.java	(date 1593162276942)
@@ -0,0 +1,14 @@
+package com.fan.zuoalgorithm.ch01.num04;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/08.
+ */
+
+public class Dog extends Pet {
+    public Dog() {
+        super("dog");
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/num04/Pet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/num04/Pet.java	(date 1593162276862)
+++ src/com/fan/zuoalgorithm/ch01/num04/Pet.java	(date 1593162276862)
@@ -0,0 +1,15 @@
+package com.fan.zuoalgorithm.ch01.num04;
+
+public class Pet {
+
+    private String type;
+
+    public Pet(String type) {
+        this.type = type;
+    }
+
+    public String getPetType() {
+        return type;
+    }
+
+}
Index: src/com/fan/zuoalgorithm/cha04/Num06.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num06.java	(date 1593162276822)
+++ src/com/fan/zuoalgorithm/cha04/Num06.java	(date 1593162276822)
@@ -0,0 +1,83 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 打气球的最大分数
+ * @date : 2020/03/21.
+ */
+
+public class Num06 {
+    public int maxCoins1(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+        if (arr.length == 1) {
+            return arr[0];
+        }
+        int n = arr.length;
+        int[] help = new int[n + 2];
+        help[0] = 1;
+        help[n + 1] = 1;
+        for (int i = 0; i < n; i++) {
+            help[i + 1] = arr[i];
+        }
+        return process(help, 1, n);
+    }
+
+    private int process(int[] arr, int L, int R) {
+        if (L == R) {
+            return arr[L - 1] * arr[L] * arr[R + 1];
+        }
+        // 最后打爆arr[L]的方案和最后打爆arr[R]的方案，先比较一下
+        int max = Math.max(arr[L - 1] * arr[L] * arr[R + 1] + process(arr, L + 1, R),
+                arr[L - 1] * arr[R] * arr[R + 1] + process(arr, L, R - 1));
+        // 尝试中间位置最后打爆的方案
+        for (int i = L + 1; i < R; i++) {
+            max =
+                    Math.max(arr[L - 1] * arr[i] * arr[R + 1] + process(arr, L, i - 1) + process(arr, i + 1, R), max);
+        }
+        return max;
+    }
+
+    /**
+     * 动态规划
+     *
+     * @param arr
+     * @return
+     */
+    public int maxCoins2(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+        if (arr.length == 1) {
+            return arr[0];
+        }
+        int n = arr.length;
+        int[] help = new int[n + 2];
+        help[0] = 1;
+        help[n + 1] = 1;
+        for (int i = 0; i < n; i++) {
+            help[i + 1] = arr[i];
+        }
+        int[][] dp = new int[n + 2][n + 2];
+        for (int i = 1; i <= n; i++) {
+            dp[i][i] = help[i - 1] * help[i] * help[i + 1];
+            System.out.println(dp[i][i]);
+        }
+        for (int L = n; L >= 1; L--) {
+            for (int R = L + 1; R <= n; R++) {
+                int finalL = help[L - 1] * help[L] * help[R + 1] + dp[L + 1][R];
+                int finalR = help[L - 1] * help[R] * help[R + 1] + dp[L][R - 1];
+                dp[L][R] = Math.max(finalL, finalR);
+                // 中间位置的情况
+                for (int i = L + 1; i < R; i++) {
+                    dp[L][R] = Math.max(dp[L][R],
+                            help[L - 1] * help[i] * help[R + 1] + dp[L][i - 1] + dp[i + 1][R]);
+                }
+            }
+        }
+        return dp[1][n];
+
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num20.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num20.java	(date 1593162277256)
+++ src/com/fan/zuoalgorithm/ch02/Num20.java	(date 1593162277256)
@@ -0,0 +1,41 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 按照左右半区的形式重新组合单链表
+ * @date : 2019/12/03.
+ */
+
+public class Num20 {
+
+    public static void relocate(Node head) {
+        if (head == null || head.next == null) {
+            return;
+        }
+        Node mid = head;
+        Node right = head.next;
+        // find the mid
+        while (right.next != null && right.next.next != null) {
+            mid = mid.next;
+            right = right.next.next;
+        }
+        // right为右半区的第一个节点
+        right = mid.next;
+        mid.next = null;
+        mergeLR(head, right);
+    }
+
+    private static void mergeLR(Node left, Node right) {
+        Node next;
+        // 画图理解组合过程
+        while (left.next != null) {
+            next = right.next;
+            right.next = left.next;
+            left.next = right;
+            left = right.next;
+            right = next;
+        }
+        left.next = right;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num07.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num07.java	(date 1593162277249)
+++ src/com/fan/zuoalgorithm/cha04/Num07.java	(date 1593162277249)
@@ -0,0 +1,111 @@
+package com.fan.zuoalgorithm.cha04;
+
+import java.util.Arrays;
+
+/**
+ * @author :  PF_23
+ * @Description : 最长递增子序列
+ * @date : 2020/03/21.
+ */
+
+public class Num07 {
+
+    /**
+     * @param arr
+     * @return
+     */
+    public int[] getdp1(int[] arr) {
+        int[] dp = new int[arr.length];
+        for (int i = 0; i < arr.length; i++) {
+            dp[i] = 1;
+            for (int j = 0; j < i; j++) {
+                if (arr[i] > arr[j]) {
+                    dp[i] = Math.max(dp[i], dp[j + 1]);
+                }
+            }
+        }
+        return dp;
+    }
+
+    public int[] generateLIS(int[] arr, int[] dp) {
+        int len = 0;
+        int index = 0;
+        // 找出最长的序列数
+        for (int i = 0; i < dp.length; i++) {
+            if (dp[i] > len) {
+                len = dp[i];
+                index = i;
+            }
+        }
+        int[] lis = new int[len];
+
+        lis[--len] = arr[index];
+        for (int i = index; i >= 0; i--) {
+            if (arr[i] < arr[index] && dp[i] == dp[index] - 1) {
+                lis[--len] = arr[i];
+                index = i;
+            }
+        }
+        return lis;
+    }
+
+    /**
+     * 暴力法
+     *
+     * @param arr
+     * @return
+     */
+    public int[] lis1(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return null;
+        }
+        int[] dp = getdp1(arr);
+        return generateLIS(arr, dp);
+    }
+
+    public int[] getdp2(int[] arr) {
+        int[] dp = new int[arr.length];
+        int[] ends = new int[arr.length];
+        ends[0] = arr[0];
+        dp[0] = 1;
+        int right = 0;
+        int l, r, m;
+
+        for (int i = 1; i < arr.length; i++) {
+            // 每次遍历arr[i]时，ends有效区域的最左下标值始终为0
+            l = 0;
+            // 每次遍历arr[i]时，更新ends有效区域的最右下标值
+            r = right;
+            while (l <= r) {
+                m = (l + r) / 2;
+                if (arr[i] > ends[m]) {
+                    l = m + 1;
+                } else {
+                    r = m - 1;
+                }
+            }
+            // 更新ends有效区的右区间值
+            right = Math.max(right, l);
+            // 找到的l就是ends有效区中最左大于等于arr[i]的值得下标
+            ends[l] = arr[i];
+            // 当前arr[0..i]的最长递增区间的长度为 l + 1
+            dp[i] = l + 1;
+        }
+        return dp;
+    }
+
+    public int[] lis2(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return null;
+        }
+        int[] dp = getdp2(arr);
+        return generateLIS(arr, dp);
+    }
+
+    public static void main(String[] args) {
+        int[] arr = {2, 1, 5, 3, 6, 4, 8, 9, 7};
+        int[] ints = new Num07().lis2(arr);
+        System.out.println(Arrays.toString(ints));
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num05.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num05.java	(date 1593162276932)
+++ src/com/fan/zuoalgorithm/ch01/Num05.java	(date 1593162276932)
@@ -0,0 +1,33 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 用一个桟实现另一个桟的排序
+ * 将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。
+ *     （1）如果cur小于或等于help的栈顶元素，则将cur直接压入help；
+ *      （2）如果cur大禹help的栈顶元素，则将该help的元素逐一弹出，逐一压入stack栈，
+ * 直到cur小于或等于help的栈顶元素，再将 cur压入help
+ * @date : 2019/11/03.
+ */
+
+public class Num05 {
+    public static void sortStackByStack(Stack<Integer> stack) {
+        Stack<Integer> help = new Stack<>();
+        while (!stack.isEmpty()) {
+            int cur = stack.pop();
+            while (!help.isEmpty() && help.peek() < cur) {
+                stack.push(help.pop());
+            }
+            help.push(cur);
+        }
+
+        while (!help.isEmpty()) {
+            stack.push(help.pop());
+        }
+    }
+
+
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num15.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num15.java	(date 1593162277161)
+++ src/com/fan/zuoalgorithm/cha04/Num15.java	(date 1593162277161)
@@ -0,0 +1,86 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 龙与地下城游戏问题
+ * @date : 2020/03/21.
+ */
+
+public class Num15 {
+    /**
+     * 动态规划常规
+     *
+     * @param m
+     * @return
+     */
+    public int minHP1(int[][] m) {
+        // dp[i][j] 表示如果骑士要走上位置（i，j），并且从该位置选一条最优的路径，最后走到右下角，骑士起码应该具备的血量。
+        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
+            return 1;
+        }
+        int row = m.length;
+        int col = m[0].length;
+        int[][] dp = new int[row--][col--];
+        // 见到公主的最低血量要求
+        dp[row][col] = m[row][col] > 0 ? 1 : -m[row][col] + 1;
+        // 初始化最后一行的血量
+        for (int i = col - 1; i >= 0; i--) {
+            dp[row][i] = Math.max(dp[row][i + 1] - m[row][i], 1);
+        }
+        int right;
+        int down;
+        for (int i = row - 1; i >= 0; i--) {
+            dp[i][col] = Math.max(dp[i + 1][col] - m[i][col], 1);
+            for (int j = col - 1; j >= 0; j--) {
+                right = Math.max(dp[i][j + 1] - m[i][j], 1);
+                down = Math.max(dp[i + 1][j] - m[i][j], 1);
+                dp[i][j] = Math.min(right, down);
+            }
+        }
+        return dp[0][0];
+    }
+
+    /**
+     * 空间压缩 + 动态规划
+     *
+     * @param m
+     * @return
+     */
+    public int minHP2(int[][] m) {
+        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
+            return 1;
+        }
+
+        int more = Math.max(m.length, m[0].length);
+        int less = Math.min(m.length, m[0].length);
+        boolean rowmore = more == m.length;
+        int[] dp = new int[less];
+        // 最右下角的值
+        int tmp = m[m.length - 1][m[0].length - 1];
+        dp[less - 1] = tmp > 0 ? 1 : -tmp + 1;
+
+        int row;
+        int col;
+        for (int j = less - 2; j >= 0; j--) {
+            row = rowmore ? more - 1 : j;
+            col = rowmore ? j : more - 1;
+            dp[j] = Math.max(dp[j + 1] - m[row][col], 1);
+        }
+        int choosen1;
+        int choosen2;
+        for (int i = more - 2; i >= 0; i--) {
+            row = rowmore ? i : more - 1;
+            col = rowmore ? less - 1 : i;
+            dp[less - 1] = Math.max(dp[less - 1] - m[row][col], 1);
+            for (int j = less - 2; j >= 0; j--) {
+                row = rowmore ? i : j;
+                col = rowmore ? j : i;
+                choosen1 = Math.max(dp[j] - m[row][col], 1);
+                choosen2 = Math.max(dp[j + 1] - m[row][col], 1);
+                dp[j] = Math.min(choosen2, choosen1);
+            }
+        }
+        return dp[0];
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/num04/DogCatQueue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/num04/DogCatQueue.java	(date 1593162277117)
+++ src/com/fan/zuoalgorithm/ch01/num04/DogCatQueue.java	(date 1593162277117)
@@ -0,0 +1,72 @@
+package com.fan.zuoalgorithm.ch01.num04;
+
+import java.util.LinkedList;
+import java.util.Queue;
+
+/**
+ * @author :  PF_23
+ * @Description : 猫狗队列 使用两个队列同时保持主队列一致，只用时间戳表示顺序的一致性
+ * @date : 2019/11/08.
+ */
+
+public class DogCatQueue {
+
+    private static final String DOG = "dog";
+    private static final String CAT = "cat";
+    private Queue<PetEnterQueue> dogQ = new LinkedList<>();
+    private Queue<PetEnterQueue> catQ = new LinkedList<>();
+    private long count = 0;
+
+    public void add(Pet pet) {
+        if (DOG.equals(pet.getPetType())) {
+            dogQ.add(new PetEnterQueue(pet, count++));
+        } else if (CAT.equals(pet.getPetType())) {
+            catQ.add(new PetEnterQueue(pet, count++));
+        } else {
+            throw new RuntimeException("error,not dog or cat");
+        }
+    }
+
+    public Pet pollAll() {
+        if (!dogQ.isEmpty() && !catQ.isEmpty()) {
+            if (dogQ.peek().getCount() < catQ.peek().getCount()) {
+                return dogQ.poll().getPet();
+            } else {
+                return catQ.poll().getPet();
+            }
+        } else if (!dogQ.isEmpty()) {
+            return dogQ.poll().getPet();
+        } else if (!catQ.isEmpty()) {
+            return catQ.poll().getPet();
+        } else {
+            throw new RuntimeException("err,queue is empty");
+        }
+    }
+
+    public Dog pollDog() {
+        if (dogQ.isEmpty()) {
+            throw new RuntimeException("Dog Queue is empty!");
+        }
+        return (Dog) dogQ.poll().getPet();
+    }
+
+    public Cat pollCat() {
+        if (catQ.isEmpty()) {
+            throw new RuntimeException("Cat Queue is empty!");
+        }
+        return (Cat) catQ.poll().getPet();
+    }
+
+    public Boolean isEmpty() {
+        return catQ.isEmpty() && dogQ.isEmpty();
+    }
+
+    public Boolean isDogQueueEmpty() {
+        return dogQ.isEmpty();
+    }
+
+    public Boolean isCatQueueEmpty() {
+        return catQ.isEmpty();
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num01.java	(date 1593162276851)
+++ src/com/fan/zuoalgorithm/ch01/Num01.java	(date 1593162276851)
@@ -0,0 +1,108 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 设计一个有getMin功能的桟
+ * 用两个桟来解答 一个桟为正常桟，另一个为（栈顶）存放最小值的桟
+ * @date : 2019/11/03.
+ */
+
+public class Num01 {
+    private Stack<Integer> stackData = new Stack<>();
+    private Stack<Integer> stackMin = new Stack<>();
+
+//    public Num01() {
+//        stackData = new Stack<>();
+//        stackMin = new Stack<>();
+//    }
+
+    // 方案一
+
+    /**
+     * 插入操作
+     *
+     * @param newNum 待插入的数
+     */
+    public void push(int newNum) {
+        if (stackMin.isEmpty()) {
+            stackMin.push(newNum);
+        } else if (newNum <= getMin()) {
+            stackMin.push(newNum);
+        }
+        stackData.push(newNum);
+    }
+
+    /**
+     * @return 栈顶元素
+     */
+    public int pop() {
+        if (stackData.isEmpty()) {
+            throw new RuntimeException(("Your Stack is empty."));
+        }
+        int value = stackData.pop();
+        // 若弹出的值是最小值，同步弹出
+        if (value == getMin()) {
+            stackMin.pop();
+        }
+        return value;
+    }
+
+    /**
+     * 获取最小值
+     *
+     * @return 最小值
+     */
+    public int getMin() {
+        if (stackMin.isEmpty()) {
+            throw new RuntimeException("Your stack is empty.");
+        }
+        return stackMin.peek();
+    }
+
+    /*--------------------------------------------------------*/
+    // 方案二
+
+    /**
+     * 插入操作，同步两个桟的元素个数
+     *
+     * @param newNum 待插入的数
+     */
+    public void push02(int newNum) {
+        if (stackMin.isEmpty()) {
+            stackMin.push(newNum);
+        } else if (newNum < getMin()) {
+            stackMin.push(newNum);
+        } else { // 当压入元素大于最小值时，最小值桟再次压入当前栈顶元素，保持与正常桟元素个数一致
+            int newMin = stackMin.peek();
+            stackMin.push(newMin);
+        }
+        stackData.push(newNum);
+    }
+
+    /**
+     * @return 栈顶元素
+     */
+    public int pop02() {
+        if (stackData.isEmpty()) {
+            throw new RuntimeException("Your stack is empty.");
+        }
+        // 同步两个桟的元素个数
+        stackMin.pop();
+        return stackData.pop();
+    }
+
+    /**
+     * 获取最小值
+     *
+     * @return 最小值
+     */
+    public int getMin02() {
+        if (stackMin.isEmpty()) {
+            throw new RuntimeException("Your stack is empty.");
+        }
+        return stackMin.peek();
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num02.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num02.java	(date 1593162276847)
+++ src/com/fan/zuoalgorithm/ch01/Num02.java	(date 1593162276847)
@@ -0,0 +1,44 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 由两个桟组成队列
+ * @date : 2019/11/03.
+ */
+
+public class Num02 {
+    public Stack<Integer> stackPush = new Stack<>();
+    public Stack<Integer> stackPop = new Stack<>();
+
+    public void pushToPop() {
+        if (stackPop.empty()) {
+            while (!stackPush.empty()) {
+                stackPop.push(stackPush.pop());
+            }
+        }
+    }
+
+    public void add(int pushInt) {
+        stackPush.push(pushInt);
+        pushToPop();
+    }
+
+    public int poll() {
+        if (stackPop.empty() && stackPush.empty()) {
+            throw new RuntimeException("Queue is empty.");
+        }
+        pushToPop();
+        return stackPop.pop();
+    }
+
+    public int peek() {
+        if (stackPop.empty() && stackPush.empty()) {
+            throw new RuntimeException("Queue is empty.");
+        }
+        pushToPop();
+        return stackPop.peek();
+    }
+}
+
Index: src/com/fan/leetcode/Solution.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/leetcode/Solution.java	(date 1593162307914)
+++ src/com/fan/leetcode/Solution.java	(date 1593162307914)
@@ -0,0 +1,60 @@
+package com.fan.leetcode;
+
+import java.util.Arrays;
+
+class Solution {
+    public int minIncrementForUnique(int[] A) {
+
+        if (A == null || A.length == 0) {
+            return 0;
+        }
+        int[] count = new int[80000];
+        for (int x : A) {
+            count[x]++;
+        }
+
+        int ans = 0, taken = 0;
+
+        for (int x = 0; x < 80000; x++) {
+            if (count[x] >= 2) {
+                // x是重复数字
+                taken += count[x] - 1;
+                ans -= (x * (count[x] - 1));
+            } else if (count[x] == 0) {
+                // x未出现过
+                taken--;
+                ans += x;
+            }
+        }
+        return ans;
+    }
+
+    public int minIncrementForUnique2(int[] A) {
+
+        Arrays.sort(A);
+        int ans = 0, taken = 0;
+        for (int i = 1; i < A.length; ++i) {
+            if (A[i - 1] == A[i]) {
+                // 如果 A[i - 1] == A[i]，我们将操作次数减去 A[i]，并将重复的数的个数增加 1
+                taken++;
+                ans -= A[i];
+            } else {
+                // 如果 A[i - 1] < A[i]，则区间 [A[i−1]+1,A[i]−1] 里的数都是没有出现过的，
+                // 所以我们可以将之前重复的数变为这个区间范围内的数。
+                // 设当前重复的数的个数为 taken，
+                // 则我们最多可以改变 give = min(taken, A[i] - A[i - 1] - 1) 个数，
+                // 即区间 [A[i−1]+1,A[i]−1] 的长度与 taken 二者的较小值。它们的操作数对答案的贡献为：
+                // [A[i−1]+1,A[i]−1]数组的和，等差数列求和
+                int give = Math.min(taken, A[i] - A[i - 1] - 1);
+                taken -= give;
+                ans += give * (give + 1) / 2 + give * A[i - 1];
+            }
+        }
+        // 在扫描完数组后，如果仍然有重复的数，即 taken 不为 0，我们可以将这些数变为区间
+        // [A[n−1]+1,∞) 中的数，其中 A[n - 1] 是数组 A 中的最后一个数
+        if (taken > 0) {
+            ans += taken * (taken + 1) / 2 + taken * A[A.length - 1];
+        }
+        return ans;
+    }
+}
\ No newline at end of file
Index: src/com/fan/zuoalgorithm/ch02/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/README.md	(date 1575342933762)
+++ src/com/fan/zuoalgorithm/ch02/README.md	(date 1575342933762)
@@ -0,0 +1,3 @@
+#链表算法题总结
+主要方法有：    
+逆序、结合桟实现等
\ No newline at end of file
Index: src/com/fan/zuoalgorithm/ch01/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/README.md	(date 1575342972150)
+++ src/com/fan/zuoalgorithm/ch01/README.md	(date 1575342972150)
@@ -0,0 +1,1 @@
+#桟总结
\ No newline at end of file
Index: src/com/fan/zuoalgorithm/cha04/Num21.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num21.java	(date 1593162276875)
+++ src/com/fan/zuoalgorithm/cha04/Num21.java	(date 1593162276875)
@@ -0,0 +1,80 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : N皇后问题
+ * @date : 2020/03/21.
+ */
+
+public class Num21 {
+    /**
+     * 常规解法
+     *
+     * @param n
+     * @return
+     */
+    public int num1(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        int[] record = new int[n];
+        return process1(0, record, n);
+    }
+
+    private int process1(int i, int[] record, int n) {
+        if (i == n) {
+            return 1;
+        }
+        int res = 0;
+        for (int j = 0; j < n; j++) {
+            if (isValid(record, i, j)) {
+                record[i] = j;
+                res += process1(i + 1, record, n);
+            }
+        }
+        return res;
+    }
+
+    private boolean isValid(int[] record, int i, int j) {
+        for (int k = 0; k < i; ++k) {
+            // 不满足n皇后要求
+            if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+
+    /**
+     * 最优解：位运算
+     *
+     * @param n
+     * @return
+     */
+    public int num2(int n) {
+        if (n < 1 || n > 32) {
+            return 0;
+        }
+        int upperLim = n == 32 ? -1 : (1 << n) - 1;
+        return process2(upperLim, 0, 0, 0);
+    }
+
+    private int process2(int upperLim, int colLim, int leftDiaLim, int rightDiaLim) {
+        if (colLim == upperLim) {
+            return 1;
+        }
+        int pos = 0;
+        int mostRightOne = 0;
+        pos = upperLim & (~(colLim | leftDiaLim | rightDiaLim));
+        int res = 0;
+        while (pos != 0) {
+            mostRightOne = pos & (~pos + 1);
+            pos = pos - mostRightOne;
+            res += process2(upperLim, colLim | mostRightOne, (leftDiaLim | mostRightOne) << 1,
+                    (rightDiaLim | mostRightOne) >> 1);
+        }
+        return res;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num09.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num09.java	(date 1593162276992)
+++ src/com/fan/zuoalgorithm/cha04/Num09.java	(date 1593162276992)
@@ -0,0 +1,27 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 汉诺塔问题
+ * @date : 2020/03/21.
+ */
+
+public class Num09 {
+    public void hanoi(int n) {
+        if (n > 0) {
+            func(n, "left", "mid", "right");
+        }
+    }
+
+    private void func(int n, String from, String mid, String to) {
+        if (n == 1) {
+            System.out.println("move from " + from + " to " + to);
+        } else {
+            func(n - 1, from, to, mid);
+            func(1, from, mid, to);
+            func(n - 1, mid, from, to);
+
+        }
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Test.java	(date 1593162277072)
+++ src/com/fan/zuoalgorithm/ch01/Test.java	(date 1593162277072)
@@ -0,0 +1,23 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Arrays;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2019/11/04.
+ */
+
+public class Test {
+    public static void main(String[] args) {
+        int[] a = {1,2,3};
+        int[] b = {4,5,6,7};
+        a = b;
+        byte c = (byte) 0b10000010;
+        // 有符号右移，原高位是什么，右移后高位依然是什么
+        c = (byte) (c >> 1);
+        System.out.println(c);
+        System.out.println(Arrays.toString(a));
+    }
+}
+
Index: src/com/fan/crackingthecodinginterview/chap02/Num04.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/crackingthecodinginterview/chap02/Num04.java	(date 1592575550459)
+++ src/com/fan/crackingthecodinginterview/chap02/Num04.java	(date 1592575550459)
@@ -0,0 +1,57 @@
+package com.fan.crackingthecodinginterview.chap02;
+
+import com.fan.util.ListNode;
+
+/**
+ * @author : PF_23
+ * @Description : Partition: Write code to partition a linked list around a value x,
+ * such that all nodes less than x come before all nodes greater than or equal to x.
+ * If x is contained within the list the values of x only need to be after the elements less than x (see below).
+ * The partition element x can appear anywhere in the "right partition";
+ * it does not need to appear between the left and right partitions.
+ * SOLUTION
+ * EXAMPLE
+ * Input: 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1[partition=5]
+ * Output: 3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8
+ * @date : 2020/06/19.
+ */
+
+public class Num04 {
+    public static ListNode partition(ListNode node, int x) {
+        ListNode beforeStart = null;
+        ListNode beforeEnd = null;
+        ListNode afterStart = null;
+        ListNode afterEnd = null;
+        while (node != null) {
+            ListNode next = node.next;
+            node.next = null;
+            if (node.val < x) {
+                if (beforeStart == null) {
+                    beforeStart = node;
+                    beforeEnd = beforeStart;
+                } else {
+                    beforeStart.next = node;
+                    beforeEnd = node;
+                }
+            } else {
+                if (afterStart == null) {
+                    afterStart = node;
+                    afterEnd = afterStart;
+                } else {
+                    afterStart.next = node;
+                    afterEnd = node;
+                }
+            }
+            node = next;
+        }
+
+        if (beforeStart == null) {
+            return afterStart;
+        }
+        beforeEnd.next = afterStart;
+        return beforeStart;
+    }
+
+    // 方法2 ： 创建两条链表，最后连接小的和大的
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num05.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num05.java	(date 1593162276833)
+++ src/com/fan/zuoalgorithm/cha04/Num05.java	(date 1593162276833)
@@ -0,0 +1,158 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 换钱的方法数
+ * @date : 2020/03/21.
+ */
+
+public class Num05 {
+    /**
+     * 暴力
+     *
+     * @param arr
+     * @param aim
+     * @return
+     */
+    public int coins1(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return 0;
+        }
+        return process1(arr, 0, aim);
+    }
+
+    private int process1(int[] arr, int index, int aim) {
+        int res = 0;
+        if (index == arr.length) {
+            res = aim == 0 ? 1 : 0;
+        } else {
+            for (int i = 0; i * arr[index] <= aim; i++) {
+                res += process1(arr, index + 1, aim - i * arr[index]);
+            }
+        }
+        return res;
+    }
+
+    /**
+     * 记忆搜索法
+     *
+     * @param arr
+     * @param aim
+     * @return
+     */
+    public int coins2(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return 0;
+        }
+        int[][] map = new int[arr.length + 1][aim + 1];
+        return process2(arr, 0, aim, map);
+    }
+
+    private int process2(int[] arr, int index, int aim, int[][] map) {
+        int res = 0;
+        if (index == arr.length) {
+            res = aim == 0 ? 1 : 0;
+        } else {
+            int mapValue;
+            for (int i = 0; i * arr[index] <= aim; i++) {
+                mapValue = map[index = 1][aim - i * arr[index]];
+                if (mapValue != 0) {
+                    res += mapValue == -1 ? 0 : mapValue;
+                } else {
+                    res += process2(arr, index + 1, aim - i * arr[index], map);
+                }
+            }
+        }
+        map[index][aim] = res == 0 ? -1 : res;
+        return res;
+    }
+
+
+    /**
+     * 动态规划套路法 与上一题套路一样，画表格，结果为找出的位置的值
+     *
+     * @param arr
+     * @param aim
+     * @return
+     */
+    public int coins3(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return 0;
+        }
+        int[][] dp = new int[arr.length][aim + 1];
+        // 第一列
+        for (int i = 0; i < arr.length; i++) {
+            dp[i][0] = 1;
+        }
+        // 第一行
+        for (int i = 0; i * arr[0] <= aim; i++) {
+            dp[0][i * arr[0]] = 1;
+        }
+        int num = 0;
+        for (int i = 1; i < arr.length; i++) {
+            for (int j = 1; j <= aim; j++) {
+                num = 0;
+                for (int k = 0; j - arr[i] * k >= 0; k++) {
+                    num += dp[i - 1][j - arr[i] * k];
+                }
+                dp[i][j] = num;
+            }
+        }
+        return dp[arr.length - 1][aim];
+    }
+
+
+    /**
+     * 优化空间的动态规划法
+     *
+     * @param arr
+     * @param aim
+     * @return
+     */
+    public int coins4(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return 0;
+        }
+        int[][] dp = new int[arr.length][aim + 1];
+        // 第一列
+        for (int i = 0; i < arr.length; i++) {
+            dp[i][0] = 1;
+        }
+        // 第一行
+        for (int i = 0; i * arr[0] <= aim; i++) {
+            dp[0][arr[0] * i] = 1;
+        }
+        for (int i = 1; i < arr.length; i++) {
+            for (int j = 1; j <= aim; j++) {
+                dp[i][j] = dp[i - 1][j];
+                dp[i][j] += j - arr[i] >= 0 ? dp[i][j - arr[i]] : 0;
+            }
+        }
+        return dp[arr.length - 1][aim];
+    }
+
+    /**
+     * 优化的动态规划 + 空间压缩法 （最优解）
+     *
+     * @param arr
+     * @param aim
+     * @return
+     */
+    public int coins5(int[] arr, int aim) {
+        if (arr == null || arr.length == 0 || aim < 0) {
+            return 0;
+        }
+        int[] dp = new int[aim + 1];
+        // 第一行
+        for (int i = 0; i * arr[0] <= aim; i++) {
+            dp[arr[0] * i] = 1;
+        }
+        for (int i = 1; i <= arr.length; i++) {
+            for (int j = 1; j <= aim; j++) {
+                dp[j] += j - arr[i] >= 0 ? dp[j - arr[i]] : 0;
+            }
+        }
+        return dp[aim];
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num11.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num11.java	(date 1593162277033)
+++ src/com/fan/zuoalgorithm/cha04/Num11.java	(date 1593162277033)
@@ -0,0 +1,114 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2020/03/21.
+ */
+
+public class Num11 {
+
+    public int[][] getdp(char[] str1, char[] str2) {
+        int[][] dp = new int[str1.length][str2.length];
+        for (int i = 0; i < str1.length; i++) {
+            if (str1[i] == str2[0]) {
+                dp[i][0] = 1;
+            }
+        }
+        for (int i = 0; i < str2.length; i++) {
+            if (str2[i] == str1[0]) {
+                dp[0][i] = 1;
+            }
+        }
+        for (int i = 1; i < str1.length; i++) {
+            for (int j = 1; j < str2.length; j++) {
+                if (str1[i] == str2[j]) {
+                    dp[i][j] = dp[i - 1][j - 1] + 1;
+                }
+            }
+        }
+        return dp;
+    }
+
+    public String lcst1(String str1, String str2) {
+        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
+            return "";
+        }
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        int[][] dp = getdp(chs1, chs2);
+        int end = 0;
+        int max = 0;
+//        for (int i = 0; i < chs1.length; i++) {
+//            for (int j = 0; j < chs2.length; j++) {
+//                if (dp[i][j] > max) {
+//                    max = dp[i][j];
+//                    end = i;
+//                }
+//            }
+//        }
+//        return str1.substring(end - max + 1, end + 1);
+        for (int i = 0; i < chs1.length; i++) {
+            for (int j = 0; j < chs2.length; j++) {
+                if (dp[i][j] > max) {
+                    max = dp[i][j];
+                    end = j;
+                }
+            }
+        }
+        return str2.substring(end - max + 1, end + 1);
+    }
+
+    /**
+     * 优化的动态规划
+     *
+     * @param str1
+     * @param str2
+     * @return
+     */
+    public String lcst2(String str1, String str2) {
+        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
+            return "";
+        }
+        char[] chs1 = str1.toCharArray();
+        char[] chs2 = str2.toCharArray();
+        // 斜线开始位置的行
+        int row = 0;
+
+        // 斜线开始位置的列
+        int col = chs2.length - 1;
+        // 记录最大长度
+        int max = 0;
+        // 最大长度更新时，记录子串的结尾位置
+        int end = 0;
+        while (row < chs1.length) {
+            int i = row;
+            int j = col;
+            int len = 0;
+            // 从(i,j)开始向左下方遍历
+            while (i < chs1.length && j < chs2.length) {
+                if (chs1[i] != chs2[j]) {
+                    len = 0;
+                } else {
+                    len++;
+                }
+                // 记录最大值，以及结束字符的位置
+                if (len > max) {
+                    max = len;
+                    end = i;
+                }
+                i++;
+                j++;
+            }
+            if (col > 0) {
+                // 斜线开始位置的列先向左移动
+                col--;
+            } else {
+                // 列移动到最左之后，行向下移动
+                row++;
+            }
+        }
+        return str1.substring(end - max + 1, end + 1);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num04.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num04.java	(date 1593162276800)
+++ src/com/fan/zuoalgorithm/cha04/Num04.java	(date 1593162276800)
@@ -0,0 +1,115 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 机器人达到指定位置的方法数
+ * @date : 2020/03/21.
+ */
+
+public class Num04 {
+    /**
+     * 暴力递归法
+     *
+     * @param N    : 位置1~N, 固定参数
+     * @param cur  机器人当前位置， 可变参数
+     * @param rest 还剩rest步没走，可变参数
+     * @param p    最终目标位置p,固定参数
+     * @return
+     */
+    public int walk(int N, int cur, int rest, int p) {
+        if (rest == 0) {
+            // 走完时当前位置是否在目标位置上，是则之前的移动是有效的记为1，否则无效记为0
+            return cur == p ? 1 : 0;
+        }
+        if (cur == 1) {
+            return walk(N, 2, rest - 1, p);
+        }
+
+        if (cur == N) {
+            return walk(N, N - 1, rest - 1, p);
+        }
+        return walk(N, cur + 1, rest - 1, p) + walk(N, cur - 1, rest - 1, p);
+    }
+
+    /**
+     * 主方法
+     *
+     * @param N
+     * @param M
+     * @param K
+     * @param P
+     * @return
+     */
+    public int ways1(int N, int M, int K, int P) {
+        if (N < 2 || K < 1 || M < 1 || M > N || P < 1 || P > N) {
+            return 0;
+        }
+        return walk(N, M, K, P);
+    }
+
+    /**
+     * 动态规划
+     *
+     * @param N
+     * @param M
+     * @param K
+     * @param P
+     * @return
+     */
+    public int ways2(int N, int M, int K, int P) {
+        if (N < 2 || K < 1 || M < 1 || M > N || P < 1 || P > N) {
+            return 0;
+        }
+        // 建立一张表
+        int[][] dp = new int[K + 1][N + 1];
+        // 初始化第一行, 其他的都为0
+        dp[0][P] = 1;
+        for (int i = 1; i <= K; i++) {
+            for (int j = 1; j <= N; j++) {
+                if (j == 1) {
+                    dp[i][j] = dp[i - 1][2];
+                } else if (j == N) {
+                    dp[i][j] = dp[i - 1][N - 1];
+                } else if (j > 1 && j < N) {
+                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j + 1];
+                }
+            }
+        }
+        return dp[K][M];
+
+    }
+
+    /**
+     * 动态规划 + 压缩空间
+     *
+     * @param N
+     * @param M
+     * @param K
+     * @param P
+     * @return
+     */
+    public int ways3(int N, int M, int K, int P) {
+        if (N < 2 || K < 1 || M < 1 || M > N || P < 1 || P > N) {
+            return 0;
+        }
+        int[] dp = new int[N + 1];
+        dp[P] = 1;
+        for (int i = 1; i <= K; ++i) {
+            // 左上角的值:每次更新一行的值得时候都要更新左上角的值为dp[1]
+            int leftUp = dp[1];
+            for (int j = 1; j <= N; j++) {
+                int tmp = dp[j];
+                if (j == 1) {
+                    dp[j] = dp[j + 1];
+                } else if (j == N) {
+                    dp[j] = leftUp;
+                } else {
+                    dp[j] = leftUp + dp[j + 1];
+                }
+                leftUp = tmp;
+            }
+        }
+        return dp[M];
+    }
+}
+
Index: src/com/fan/jdk/source/IntegerStudy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/jdk/source/IntegerStudy.java	(date 1593081005757)
+++ src/com/fan/jdk/source/IntegerStudy.java	(date 1593081005757)
@@ -0,0 +1,46 @@
+package com.fan.jdk.source;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * @author : PF_23
+ * @Description :
+ * @date : 2020/06/25.
+ */
+
+public class IntegerStudy {
+    public static void main(String[] args) {
+
+        int num = 100;
+        System.out.println(num & -num);
+        System.out.println("=====================");
+        Integer integer = new Integer("52");
+        System.out.println(integer);
+
+        // 结果是-1.无符号比较时，3 < -5即 3 < 5
+        int i = Integer.compareUnsigned(3, -5);
+        System.out.println(i);
+
+        String[] arr = {"12", "21", "23"};
+
+        List<Integer> list = new ArrayList<>();
+        list.add(1);
+        list.add(2);
+        list.add(3);
+        Iterator iterator = list.iterator();
+        while (iterator.hasNext()) {
+            Integer next = (Integer) iterator.next();
+            System.out.println(next);
+            iterator.remove();
+        }
+        System.out.println("=====================");
+        List<String> collect = Arrays.stream(arr).map(a -> a + a).collect(Collectors.toList());
+        List<String> stringList = collect.stream().map(c -> c + c).collect(Collectors.toList());
+        collect.forEach(System.out::println);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num12.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num12.java	(date 1593162276858)
+++ src/com/fan/zuoalgorithm/ch02/Num12.java	(date 1593162276858)
@@ -0,0 +1,127 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 将单链表的每K个节点之间逆序
+ * 最后不够K个节点一组就不逆序
+ * @date : 2019/12/02.
+ */
+
+public class Num12 {
+
+    /**
+     * method one: stack
+     *
+     * @param head
+     * @param k
+     * @return
+     */
+    private static Node reverseKNodes1(Node head, int k) {
+        if (k < 2) {
+            return head;
+        }
+        Stack<Node> stack = new Stack<>();
+        Node newHead = head;
+        Node cur = head;
+        Node pre = null;
+        Node next = null;
+        while (cur != null) {
+            next = cur.next;
+            stack.push(cur);
+            if (stack.size() == k) {
+                pre = resign1(stack, pre, next);
+                // 确定新的链表头
+                newHead = newHead == head ? cur : newHead;
+            }
+            cur = next;
+        }
+        return newHead;
+    }
+
+    private static Node resign1(Stack<Node> stack, Node left, Node right) {
+        Node cur = stack.pop();
+        if (left != null) {
+            left.next = cur;
+        }
+        Node next;
+        while (!stack.isEmpty()) {
+            next = stack.pop();
+            cur.next = next;
+            cur = next;
+        }
+        cur.next = right;
+        return cur;
+    }
+
+    /**
+     * method two
+     *
+     * @param head
+     * @param k
+     * @return
+     */
+    private static Node reverseKNodes2(Node head, int k) {
+        if (k < 2) {
+            return head;
+        }
+
+        Node cur = head;
+        Node start = null;
+        Node pre = null;
+        Node next = null;
+        int count = 1;
+
+        while (cur != null) {
+            next = cur.next;
+            if (count == k) {
+                start = pre == null ? head : pre.next;
+                head = pre == null ? cur : head;
+                resign2(pre, start, cur, next);
+                pre = start;
+                count = 0;
+            }
+            count++;
+            cur = next;
+        }
+
+        return head;
+    }
+
+    private static void resign2(Node left, Node start, Node end, Node right) {
+        Node pre = start;
+        Node cur = start.next;
+        Node next = null;
+
+        while (cur != right) {
+            next = cur.next;
+            cur.next = pre;
+            pre = cur;
+            cur = next;
+        }
+        // 链接两段逆序后的指针1->2->3->4->5->6 ： 3->2->1->4->5->6
+        if (left != null) {
+            left.next = end;
+        }
+        // 调整头尾指针 1->2->3->4 : 3->2->1->4
+        start.next = right;
+    }
+
+    public static void main(String[] args) {
+        Node head = new Node(1);
+        head.next = new Node(2);
+        head.next.next = new Node(3);
+        head.next.next.next = new Node(4);
+        head.next.next.next.next = new Node(5);
+        head.next.next.next.next.next = new Node(6);
+        head.next.next.next.next.next.next = new Node(7);
+        head.next.next.next.next.next.next.next = new Node(8);
+        head.next.next.next.next.next.next.next.next = new Node(9);
+        head.next.next.next.next.next.next.next.next.next = new Node(10);
+
+        Node node = reverseKNodes2(head, 3);
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num02.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num02.java	(date 1593162277052)
+++ src/com/fan/zuoalgorithm/ch02/Num02.java	(date 1593162277052)
@@ -0,0 +1,75 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 在单链表和双链表中删除倒数第K个节点
+ * @date : 2019/11/11.
+ */
+
+public class Num02 {
+    /**
+     * 单链表中删除
+     *
+     * @param head    头节点
+     * @param lastKth k
+     * @return 头结点
+     */
+    public Node RemoveLastKthNode(Node head, int lastKth) {
+        if (head == null || lastKth < 1) {
+            return head;
+        }
+        Node cur = head;
+        while (cur != null) {
+            lastKth--;
+            cur = cur.next;
+        }
+        if (lastKth == 0) {
+            head = head.next;
+        }
+
+        if (lastKth < 0) {
+            cur = head;
+            while (++lastKth != 0) {
+                cur = cur.next;
+            }
+            // 删除cur.next节点
+            cur.next = cur.next.next;
+        }
+        return head;
+    }
+
+    /**
+     * 双链表中删除
+     *
+     * @param head    头结点
+     * @param lastKth K
+     * @return 头结点
+     */
+    public DoubleNode RemoveLastKthNode(DoubleNode head, int lastKth) {
+        if (head == null || lastKth < 1) {
+            return head;
+        }
+        DoubleNode cur = head;
+        while (cur != null) {
+            lastKth--;
+            cur = cur.next;
+        }
+        if (lastKth == 0) {
+            head = head.next;
+            head.last = null;
+        }
+        if (lastKth < 0) {
+            cur = head;
+            while (++lastKth != 0) {
+                cur = cur.next;
+            }
+            DoubleNode newNext = cur.next.next;
+            cur.next = newNext;
+            if (newNext != null) {
+                newNext.last = null;
+            }
+        }
+        return head;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num16.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num16.java	(date 1593162276946)
+++ src/com/fan/zuoalgorithm/ch02/Num16.java	(date 1593162276946)
@@ -0,0 +1,71 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 单链表的选择排序
+ * @date : 2019/12/03.
+ */
+
+public class Num16 {
+
+    /**
+     * 时间复杂度为O(N²),空间为O(1)
+     *
+     * @param head
+     * @return
+     */
+    public static Node selectionSort(Node head) {
+        // 排序部分的尾部
+        Node tail = null;
+        // 未排序部分的头部
+        Node cur = head;
+        // 未排序部分最小节点的前一个节点
+        Node smallPre = null;
+        // 未排序部分最小节点
+        Node small = null;
+
+        while (cur != null) {
+            // 1.small = cur;
+            small = cur;
+            smallPre = getSmallPreNode(cur);
+            if (smallPre != null) {
+                small = smallPre.next;
+                smallPre.next = small.next;
+            }
+            cur = cur == small ? cur.next : cur;
+            if (tail != null) {
+                tail.next = small;
+            } else {
+                head = small;
+            }
+            tail = small;
+        }
+
+        return head;
+    }
+
+    private static Node getSmallPreNode(Node head) {
+        Node smallPre = null;
+        Node small = head;
+        Node pre = head;
+        Node cur = head.next;
+        while (cur != null) {
+            if (cur.value < small.value) {
+                small = cur;
+                smallPre = pre;
+            }
+            pre = cur;
+            cur = cur.next;
+        }
+        return smallPre;
+    }
+
+    public static void main(String[] args) {
+        Node head = new Node(2);
+        head.next = new Node(1);
+        head.next.next = new Node(3);
+
+        Node node = selectionSort(head);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num01.java	(date 1593162277025)
+++ src/com/fan/zuoalgorithm/ch02/Num01.java	(date 1593162277025)
@@ -0,0 +1,28 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 打印两个有序链表的公共部分
+ * 思路：
+ * 两个有序链表，一次从头结点遍历，若节点值相等，则输出；否则节点值小的节点指向下一个节点，知道其中一个链表遍历结束
+ * @date : 2019/11/11.
+ */
+
+public class Num01 {
+    public void printCommonPart(Node head1, Node head2) {
+        System.out.println("Common Part: ");
+        while (head1 != null && head2 != null) {
+            if (head1.value < head2.value) {
+                head1 = head1.next;
+            } else if (head1.value > head2.value) {
+                head2 = head2.next;
+            } else {
+                System.out.println(head1.value + " ");
+                head1 = head1.next;
+                head2 = head2.next;
+            }
+        }
+        System.out.println();
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num01PlusOne.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num01PlusOne.java	(date 1593162277188)
+++ src/com/fan/zuoalgorithm/cha04/Num01PlusOne.java	(date 1593162277188)
@@ -0,0 +1,65 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 跳台阶
+ * @date : 2020/03/21.
+ */
+
+public class Num01PlusOne {
+    public int s1(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n <= 2) {
+            return n;
+        }
+
+        return s1(n - 1) + s1(n - 2);
+    }
+
+    /**
+     * O(N)
+     *
+     * @param n
+     * @return
+     */
+    public int s2(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n <= 2) {
+            return n;
+        }
+
+        int pre1 = 1;
+        int pre2 = 2;
+        int res = 0;
+        for (int i = 3; i <= n; i++) {
+            res = pre1 + pre2;
+            pre1 = pre2;
+            pre2 = res;
+        }
+        return res;
+    }
+
+    /**
+     * 利用矩阵乘积使得时间复杂度为O(logN)
+     *
+     * @param n
+     * @return
+     */
+    public int s3(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n <= 2) {
+            return n;
+        }
+
+        int[][] base = {{1, 1}, {1, 0}};
+        int[][] res = MatrixPowerUtil.matrixPower(base, n - 2);
+        return 2 * res[0][0] + res[1][0];
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num19.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num19.java	(date 1593162276928)
+++ src/com/fan/zuoalgorithm/cha04/Num19.java	(date 1593162276928)
@@ -0,0 +1,27 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 跳跃游戏
+ * @date : 2020/03/21.
+ */
+
+public class Num19 {
+    public int jump(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+        int jump = 0;
+        int cur = 0;
+        int next = 0;
+        for (int i = 0; i < arr.length; i++) {
+            if (cur < i) {
+                jump++;
+                cur = next;
+            }
+            next = Math.max(next, i + arr[i]);
+        }
+        return jump;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num10.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num10.java	(date 1593162276826)
+++ src/com/fan/zuoalgorithm/ch02/Num10.java	(date 1593162276826)
@@ -0,0 +1,104 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 两个单链表生成相加链表
+ * @date : 2019/11/21.
+ */
+
+public class Num10 {
+    /**
+     * 方法一： 常规
+     *
+     * @param head1 头1
+     * @param head2 头2
+     * @return 结果头节点
+     */
+    public static Node addList1(Node head1, Node head2) {
+        Stack<Integer> stack1 = new Stack<>();
+        Stack<Integer> stack2 = new Stack<>();
+        while (head1 != null) {
+            stack1.push(head1.value);
+            head1 = head1.next;
+        }
+        while (head2 != null) {
+            stack2.push(head2.value);
+            head2 = head2.next;
+        }
+        // 进位
+        int ca = 0;
+        int n1, n2, n;
+        Node node = null;
+        Node pre;
+        while (!stack1.isEmpty() || !stack2.isEmpty()) {
+            n1 = stack1.isEmpty() ? 0 : stack1.pop();
+            n2 = stack2.isEmpty() ? 0 : stack2.pop();
+            n = n1 + n2 + ca;
+            pre = node;
+            node = new Node(n % 10);
+            node.next = pre;
+            ca = n / 10;
+        }
+        if (ca == 1) {
+            pre = node;
+            node = new Node(1);
+            node.next = pre;
+        }
+        return node;
+    }
+
+    /**
+     * 方法二： 反转链表，然后相加，然后求出结果链表，恢复链表，返回结果链表头
+     *
+     * @param head1 头1
+     * @param head2 头2
+     * @return 结果链表头
+     */
+    public static Node addList2(Node head1, Node head2) {
+        head1 = reverseList(head1);
+        head2 = reverseList(head2);
+        int n1, n2, n;
+        int ca = 0;
+        Node c1 = head1;
+        Node c2 = head2;
+        Node node = null;
+        Node pre;
+        while (c1 != null || c2 != null) {
+            n1 = c1 != null ? c1.value : 0;
+            n2 = c2 != null ? c2.value : 0;
+            n = n1 + n2 + ca;
+            pre = node;
+            node = new Node(n % 10);
+            node.next = pre;
+            ca = n / 10;
+            c1 = c1 == null ? null : c1.next;
+            c2 = c2 == null ? null : c2.next;
+        }
+        if (ca == 1) {
+            pre = node;
+            node = new Node(1);
+            node.next = pre;
+        }
+        reverseList(head1);
+        reverseList(head2);
+        return node;
+    }
+
+    private static Node reverseList(Node head) {
+        Node pre = null;
+        Node next;
+        while (head != null) {
+            next = head.next;
+            // 反转
+            head.next = pre;
+            pre = head;
+            // 右移
+            head = next;
+
+        }
+        return pre;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num08.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num08.java	(date 1593162276973)
+++ src/com/fan/zuoalgorithm/ch02/Num08.java	(date 1593162276973)
@@ -0,0 +1,144 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.PriorityQueue;
+import java.util.Queue;
+
+/**
+ * @author :  PF_23
+ * @Description :将单向链表按某值划分成左边小、中间相等、右边大的形式
+ * @date : 2019/11/19.
+ */
+
+public class Num08 {
+    /**
+     * O(N)、O(N)解法
+     *
+     * @param head
+     * @param pivot
+     * @return
+     */
+    public static Node listPartition1(Node head, int pivot) {
+        if (head == null || head.next == null) {
+            return head;
+        }
+        // 将链表放入一个数组中，调整
+        Node cur = head;
+        int i = 0;
+        while (cur != null) {
+            ++i;
+            cur = cur.next;
+        }
+        Node[] arr = new Node[i];
+        cur = head;
+        i = 0;
+        while (cur != null) {
+            arr[i++] = cur;
+            cur = cur.next;
+        }
+        arrPartition(arr, pivot);
+        for (int j = 1; j < arr.length; j++) {
+            arr[j - 1].next = arr[j];
+        }
+        arr[i - 1].next = null;
+        return arr[0];
+    }
+
+    private static void arrPartition(Node[] arr, int pivot) {
+        int small = -1;
+        int big = arr.length;
+        int index = 0;
+        while (index != big) {
+            if (arr[index].value < pivot) {
+                swap(arr, ++small, index++);
+            } else if (arr[index].value == pivot) {
+                index++;
+            } else {
+                swap(arr, --big, index);
+            }
+        }
+    }
+
+    private static void swap(Node[] arr, int i, int index) {
+        Node tmp = arr[i];
+        arr[i] = arr[index];
+        arr[index] = tmp;
+    }
+
+    public static Node listPartition2(Node head, int pivot) {
+        // 小的头
+        Node sH = null;
+        // 小的尾
+        Node sT = null;
+        // 相等的头
+        Node eH = null;
+        // 相等的尾
+        Node eT = null;
+        // 大的头
+        Node bH = null;
+        // 大的尾
+        Node bT = null;
+        // 保存下一个节点
+        Node next = null;
+        // 所有的节点分进三个链表
+        while (head != null) {
+            next = head.next;
+            head.next = null;
+            if (head.value < pivot) {
+                // 小为空
+                if (sH == null) {
+                    sH = head;
+                    sT = head;
+                } else {
+                    sT.next = head;
+                    sT = head;
+                }
+            } else if (head.value == pivot) {
+                if (eH == null) {
+                    eH = head;
+                    eT = head;
+                } else {
+                    eT.next = head;
+                    eT = head;
+                }
+            } else {
+                if (bH == null) {
+                    bH = head;
+                    bT = head;
+                } else {
+                    bT.next = head;
+                    bT = head;
+                }
+            }
+            head = next;
+        }
+        // 小的和相等的重新连接
+        if (sT != null) {
+            sT.next = eH;
+            eT = eT == null ? sT : eT;
+        }
+        // 所有的重新连接
+        if (eT != null) {
+            eT.next = bH;
+        }
+        return sH != null ? sH : eH != null ? eH : bH;
+    }
+
+    public static void main(String[] args) {
+        Node node = new Node(9);
+        Node node2 = new Node(0);
+        Node node3 = new Node(5);
+        Node node4 = new Node(4);
+        Node node5 = new Node(1);
+        node.next = node2;
+        node2.next = node3;
+        node3.next = node4;
+        node4.next = node5;
+        node5.next = null;
+
+        int pivot = 3;
+        Node node1 = listPartition1(node, pivot);
+
+        Queue q = new PriorityQueue();
+    }
+}
+
Index: src/com/fan/crackingthecodinginterview/chap02/Num03.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.fan.crackingthecodinginterview.chap02;\n\nimport com.fan.util.ListNode;\n\nimport java.util.List;\n\n/**\n * @author : PF_23\n * @Description : Delete Middle Node: Implement an algorithm to delete a node in the middle\n * (i.e., any node but the first and last node, not necessarily the exact middle) of a singly linked list,\n * given only access to that node.\n * EXAMPLE\n * lnput:the node c from the linked list a->b->c->d->e->f\n * Result: nothing is returned, but the new linked list looks like a->b->d->e- >f\n * @date : 2020/06/18.\n */\n\npublic class Num03 {\n\n    public ListNode delMid(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        if (head.next.next == null) {\n            return head.next;\n        }\n        ListNode fast = head.next.next, slow = head;\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode cur = head;\n        while (cur.next != slow) {\n            cur = cur.next;\n        }\n        cur.next = slow.next;\n        return head;\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/crackingthecodinginterview/chap02/Num03.java	(revision a3f26ab200a40cbc12a25ebc3cf30833210e36e0)
+++ src/com/fan/crackingthecodinginterview/chap02/Num03.java	(date 1592575550453)
@@ -12,7 +12,7 @@
  * EXAMPLE
  * lnput:the node c from the linked list a->b->c->d->e->f
  * Result: nothing is returned, but the new linked list looks like a->b->d->e- >f
- * @date : 2020/06/18.
+ * @date : 2020/06/18. TODO 思路对，实现没对
  */
 
 public class Num03 {
Index: src/com/fan/zuoalgorithm/ch01/Num08.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num08.java	(date 1593162276866)
+++ src/com/fan/zuoalgorithm/ch01/Num08.java	(date 1593162276866)
@@ -0,0 +1,42 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 单调桟结构
+ * @date : 2019/11/05.
+ */
+
+public class Num08 {
+    public static int[][] getNearLessNoRepeat(int[] arr) {
+        int[][] res = new int[arr.length][2];
+        Stack<Integer> stack = new Stack<>();
+
+        for (int i = 0; i < arr.length; i++) {
+            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
+                int popIndex = stack.pop();
+                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
+                res[popIndex][0] = leftLessIndex;
+                res[popIndex][1] = i;
+            }
+            stack.push(i);
+        }
+
+        // all pushed into the stack
+        while (!stack.isEmpty()) {
+            int popIndex = stack.pop();
+            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
+            res[popIndex][0] = leftLessIndex;
+            res[popIndex][1] = -1;
+        }
+        return res;
+    }
+
+    public static void main(String[] args) {
+        int[] arr = {3, 4, 1, 5, 6, 2, 7};
+        int[][] nearLessNoRepeat = getNearLessNoRepeat(arr);
+        System.out.println(nearLessNoRepeat);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num09.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num09.java	(date 1593162276922)
+++ src/com/fan/zuoalgorithm/ch01/Num09.java	(date 1593162276922)
@@ -0,0 +1,61 @@
+package com.fan.zuoalgorithm.ch01;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 求最大子矩阵的大小 延伸到接雨水
+ * @date : 2019/11/06.
+ */
+
+public class Num09 {
+    public static int maxRecSize(int[][] map) {
+        if (map == null || map.length == 0 || map[0].length == 0) {
+            return 0;
+        }
+        int maxArea = 0;
+        int[] height = new int[map[0].length];
+        for (int i = 0; i < map.length; i++) {
+            for (int j = 0; j < map[0].length; j++) {
+                // 统计每一行往上的高度
+                height[j] = map[i][j] == 0 ? 0 : height[j] + 1;
+            }
+            maxArea = Math.max(maxRecFromBottom(height), maxArea);
+        }
+        return maxArea;
+
+    }
+
+    private static int maxRecFromBottom(int[] height) {
+        if (height == null || height.length == 0) {
+            return 0;
+        }
+        int maxArea = 0;
+        // 此处利用了一个单调桟结构，桟自底向上单调递增
+        Stack<Integer> stack = new Stack<>();
+        for (int i = 0; i < height.length; i++) {
+            while (!stack.isEmpty() && height[i] <= height[stack.peek()]) {
+                int j = stack.pop();
+                int k = stack.isEmpty() ? -1 : stack.peek();
+                int curArea = (i - k - 1) * height[j];
+                maxArea = Math.max(maxArea, curArea);
+            }
+            stack.push(i);
+        }
+
+        while (!stack.isEmpty()) {
+            int j = stack.pop();
+            int k = stack.isEmpty() ? -1 : stack.peek();
+            int curArea = (height.length - k - 1) * height[j];
+            maxArea = Math.max(maxArea, curArea);
+        }
+        return maxArea;
+    }
+
+    public static void main(String[] args) {
+        int[][] map = {{1, 0, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 0}};
+        int maxRecSize = maxRecSize(map);
+        System.out.println(maxRecSize);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num12.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num12.java	(date 1593162276916)
+++ src/com/fan/zuoalgorithm/cha04/Num12.java	(date 1593162276916)
@@ -0,0 +1,38 @@
+package com.fan.zuoalgorithm.cha04;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author :  PF_23
+ * @Description : 子数组异或和为0的最多划分
+ * @date : 2020/03/21.
+ */
+
+public class Num12 {
+    public int mostEOR(int[] arr) {
+        if (arr == null || arr.length == 0) {
+            return 0;
+        }
+        int eor = 0;
+        // dp[i]含义是如果在arr[0..i]上做分割，异或和为0的子数组最多能有多少个。
+        int[] dp = new int[arr.length];
+        Map<Integer, Integer> map = new HashMap<>();
+        map.put(0, -1);
+        dp[0] = arr[0] == 0 ? 1 : 0;
+        map.put(arr[0], 0);
+        for (int i = 1; i < arr.length; i++) {
+            eor ^= arr[i];
+            if (map.containsKey(eor)) {
+                int preEorIndex = map.get(eor);
+                dp[i] = preEorIndex == -1 ? 1 : (dp[preEorIndex] + 1);
+            }
+            // 两种情况的较大值
+            dp[i] = Math.max(dp[i - 1], dp[i]);
+            // 存放eor和value键值对；要是之前存放过key为eor的值得键值对，更新值
+            map.put(eor, i);
+        }
+        return dp[dp.length - 1];
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Num08.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num08.java	(date 1593162276896)
+++ src/com/fan/zuoalgorithm/cha04/Num08.java	(date 1593162276896)
@@ -0,0 +1,35 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 信封嵌套问题
+ * @date : 2020/03/21.
+ */
+
+public class Num08 {
+    public int maxEnvelopes(int[][] matrix) {
+        Envelope[] envelopes = EnvelopeComparator.getSortedEnvelopes(matrix);
+        int[] ends = new int[matrix.length];
+        ends[0] = envelopes[0].wid;
+        int right = 0;
+        int l = 0;
+        int r = 0;
+        int m = 0;
+        for (int i = 0; i < envelopes.length; i++) {
+            l = 0;
+            r = right;
+            while (l < r) {
+                m = (l + r) / 2;
+                if (envelopes[i].wid > ends[m]) {
+                    l = m + 1;
+                } else {
+                    r = m - 1;
+                }
+            }
+            right = Math.max(right, l);
+            ends[1] = envelopes[i].wid;
+        }
+        return right + 1;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch03/Num01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch03/Num01.java	(date 1593162276837)
+++ src/com/fan/zuoalgorithm/ch03/Num01.java	(date 1593162276837)
@@ -0,0 +1,136 @@
+package com.fan.zuoalgorithm.ch03;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 分别用递归和非递归的方式实现二叉树的前序、中序和后序遍历
+ * @date : 2020/01/02.
+ */
+
+public class Num01 {
+
+    //*******************************
+    // recur
+    //*******************************
+
+    public void preOrderRecur(Node head) {
+        if (head == null) {
+            return;
+        }
+        while (head != null) {
+            System.out.println(head.value + "    ");
+            preOrderRecur(head.left);
+            preOrderRecur(head.right);
+        }
+    }
+
+    public void inOrderRecur(Node head) {
+        if (head == null) {
+            return;
+        }
+        while (head != null) {
+            inOrderRecur(head.left);
+            System.out.println(head.value + "    ");
+            inOrderRecur(head.right);
+        }
+    }
+
+    public void posOrderRecur(Node head) {
+        if (head == null) {
+            return;
+        }
+        while (head != null) {
+            posOrderRecur(head.left);
+            posOrderRecur(head.right);
+            System.out.println(head.value);
+        }
+    }
+
+    //*******************************
+    // unRecur
+    //*******************************
+
+    public void preOrderUnRecur(Node head) {
+        System.out.println("pre-order: ");
+        if (head != null) {
+            Stack<Node> stack = new Stack<>();
+            stack.push(head);
+            while (!stack.isEmpty()) {
+                head = stack.pop();
+                System.out.println(head.value + "    ");
+                if (head.right != null) {
+                    stack.push(head.right);
+                }
+                if (head.left != null) {
+                    stack.push(head.left);
+                }
+            }
+        }
+        System.out.println();
+    }
+
+    public void inOrderUnRecur(Node head) {
+        System.out.println("in-order: ");
+        if (head != null) {
+            Stack<Node> stack = new Stack<>();
+            while (!stack.isEmpty() || head != null) {
+                if (head != null) {
+                    stack.push(head);
+                    head = head.left;
+                } else {
+                    head = stack.pop();
+                    System.out.println(head.value + "    ");
+                    head = head.right;
+                }
+            }
+        }
+        System.out.println();
+    }
+
+    public void posOrderUnRecur1(Node head) {
+        System.out.println("pos-order: ");
+        if (head != null) {
+            Stack<Node> stack1 = new Stack<>();
+            Stack<Node> stack2 = new Stack<>();
+            stack1.push(head);
+            while (!stack1.isEmpty()) {
+                head = stack1.pop();
+                stack2.push(head);
+                if (head.left != null) {
+                    stack1.push(head.left);
+                }
+                if (head.right != null) {
+                    stack1.push(head.right);
+                }
+            }
+            while (!stack2.isEmpty()) {
+                System.out.println(stack2.pop().value + "    ");
+            }
+        }
+        System.out.println();
+    }
+
+    public void posOrderUnRecur2(Node head) {
+        System.out.println("pos-order:");
+        if (head != null) {
+            Stack<Node> stack = new Stack<>();
+            stack.push(head);
+            Node c = null;
+            while (!stack.isEmpty()) {
+                c = stack.peek();
+                if (c.left != null && head != c.left && head != c.right) {
+                    stack.push(c.left);
+                } else if (c.right != null && head != c.right) {
+                    stack.push(c.right);
+                } else {
+                    System.out.println(stack.pop().value + "    ");
+                    head = c;
+                }
+            }
+        }
+        System.out.println();
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/cha04/Envelope.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Envelope.java	(date 1593162277152)
+++ src/com/fan/zuoalgorithm/cha04/Envelope.java	(date 1593162277152)
@@ -0,0 +1,19 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 信封
+ * @date : 2020/03/21.
+ */
+
+public class Envelope {
+    public int len;
+    public int wid;
+
+    public Envelope(int len, int wid) {
+        this.len = len;
+        this.wid = wid;
+    }
+
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num13.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num13.java	(date 1593162276983)
+++ src/com/fan/zuoalgorithm/ch02/Num13.java	(date 1593162276983)
@@ -0,0 +1,62 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.HashSet;
+
+/**
+ * @author :  PF_23
+ * @Description : 删除无序链表中的重复值节点
+ * @date : 2019/12/02.
+ */
+
+public class Num13 {
+
+    /**
+     * method one : hashSet
+     * @param head
+     */
+    public void removeRep1(Node head) {
+        if (head == null) {
+            return;
+        }
+        HashSet<Integer> set = new HashSet<>();
+        Node pre = head;
+        Node cur = head.next;
+        set.add(head.value);
+        while (cur != null) {
+            if (set.contains(cur.value)) {
+                pre.next = cur.next;
+            } else {
+                set.add(cur.value);
+                pre = cur;
+            }
+            cur = cur.next;
+        }
+    }
+
+    /**
+     * method two: O(N²)
+     * @param head
+     */
+    public void removeRep2(Node head) {
+        if (head == null) {
+            return;
+        }
+        Node cur = head;
+        Node pre;
+        Node next;
+        while (cur != null) {
+            pre = cur;
+            next = cur.next;
+            while (next != null) {
+                if (cur.value == next.value) {
+                    pre.next = next.next;
+                } else {
+                    pre = next;
+                }
+                next = next.next;
+            }
+            cur = cur.next;
+        }
+    }
+}
+
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README.md	(date 1593064357328)
+++ README.md	(date 1593064357328)
@@ -0,0 +1,7 @@
+# 原码、反码与补码
+
+原码：整数高位为0，负数高位为1，其他就是数值本身的2进制表示
+反码：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各位取反
+补码：正数的补码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各位取反，然后+1
+
+计算机为了只有加法，在进行加法运算时使用的是 ：**补码运算**，因为同余
\ No newline at end of file
Index: src/com/fan/zuoalgorithm/ch02/Num14.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num14.java	(date 1593162276949)
+++ src/com/fan/zuoalgorithm/ch02/Num14.java	(date 1593162276949)
@@ -0,0 +1,64 @@
+package com.fan.zuoalgorithm.ch02;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 在单链表中删除指定值得节点
+ * @date : 2019/12/02.
+ */
+
+public class Num14 {
+
+    /**
+     * method one : O(N) O(N)
+     * 利用桟
+     * @param head
+     * @param num
+     * @return
+     */
+    public Node removeValue1(Node head, int num) {
+        Stack<Node> stack = new Stack<>();
+        while (head != null) {
+            if (head.value != num) {
+                stack.push(head);
+            }
+            head = head.next;
+        }
+        while (!stack.isEmpty()) {
+            stack.peek().next = head;
+            head = stack.pop();
+        }
+
+        return head;
+    }
+
+    /**
+     * method two : O(N) O(1)
+     *
+     * @param head
+     * @param num
+     * @return
+     */
+    public Node removeValue2(Node head, int num) {
+        // 找到第一个不等于num值得头结点，作为最终的头结点
+        while (head != null) {
+            if (head.value != num) {
+                break;
+            }
+            head = head.next;
+        }
+        Node pre = head;
+        Node cur = head;
+        while (cur != null) {
+            if (cur.value == num) {
+                pre.next = cur.next;
+            } else {
+                pre = cur;
+            }
+            cur = cur.next;
+        }
+        return head;
+    }
+}
+
Index: src/com/fan/jdk/source/StringStudy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/jdk/source/StringStudy.java	(date 1593067660414)
+++ src/com/fan/jdk/source/StringStudy.java	(date 1593067660414)
@@ -0,0 +1,35 @@
+package com.fan.jdk.source;
+
+/**
+ * @author : PF_23
+ * @Description :
+ * @date : 2020/06/25.
+ */
+
+public class StringStudy {
+
+    public static void main(String[] args) {
+        String s1 = "adf";
+        String s2 = "adfreqr";
+        System.out.println(s1.compareTo(s2));
+
+        String str1 = "hello";//字面量 只会在常量池中创建对象
+        String str2 = str1.intern();
+        System.out.println(str1==str2);//true
+
+        String str3 = new String("world");//new 关键字只会在堆中创建对象
+        String str4 = str3.intern();
+        System.out.println(str3 == str4);//false
+
+        String str5 = str1 + str2;//变量拼接的字符串，会在常量池中和堆中都创建对象
+        String str6 = str5.intern();//这里由于池中已经有对象了，直接返回的是对象本身，也就是堆中的对象
+        System.out.println(str5 == str6);//true
+
+        String str7 = "hello1" + "world1";//常量拼接的字符串，只会在常量池中创建对象
+        String str8 = str7.intern();
+        System.out.println(str7 == str8);//true
+    }
+
+
+}
+
Index: src/com/fan/zuoalgorithm/ch02/Num04.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch02/Num04.java	(date 1593162277126)
+++ src/com/fan/zuoalgorithm/ch02/Num04.java	(date 1593162277126)
@@ -0,0 +1,50 @@
+package com.fan.zuoalgorithm.ch02;
+
+/**
+ * @author :  PF_23
+ * @Description : 反转单向和双向链表 （必须能够熟练写出来，马上写出来）
+ * @date : 2019/11/12.
+ */
+
+public class Num04 {
+    /**
+     * 反转单链表
+     *
+     * @param head 头结点
+     * @return 反转后的链表头结点
+     */
+    public Node reverseList(Node head) {
+        Node pre = null;
+        Node next;
+
+        while (head != null) {
+            next = head.next;
+            head.next = pre;
+            pre = head;
+            head = next;
+        }
+        return pre;
+    }
+
+    /**
+     * 反转双向链表
+     *
+     * @param head 头结点
+     * @return 反转后的头结点
+     */
+    public DoubleNode reverseList(DoubleNode head) {
+        DoubleNode pre = null;
+        DoubleNode next;
+
+        while (head != null) {
+            next = head.next;
+            head.next = pre;
+            // 与单链表相比，多了这一句
+            head.last = next;
+            pre = head;
+            head = next;
+        }
+        return pre;
+    }
+}
+
Index: src/com/fan/zuoalgorithm/ch01/Num11/Num11Plus.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/ch01/Num11/Num11Plus.java	(date 1593162276819)
+++ src/com/fan/zuoalgorithm/ch01/Num11/Num11Plus.java	(date 1593162276819)
@@ -0,0 +1,88 @@
+package com.fan.zuoalgorithm.ch01.Num11;
+
+import java.util.Stack;
+
+/**
+ * @author :  PF_23
+ * @Description : 可见的山峰对数量（进阶）
+ * @date : 2019/11/10.
+ */
+
+public class Num11Plus {
+    public static int getVisibleNum(int[] arr) {
+        if (arr == null || arr.length < 2) {
+            return 0;
+        }
+        int size = arr.length;
+        int maxIndex = 0;
+        // 先在环中找到其中一个最大值的位置，哪一个都行
+        for (int i = 0; i < size; i++) {
+            maxIndex = arr[maxIndex] < arr[i] ? i : maxIndex;
+        }
+
+        Stack<Record> stack = new Stack<>();
+        // 先把（最大值，1）这个记录放入到stack中
+        stack.push(new Record(arr[maxIndex]));
+        // 从最大值位置的下一个位置开始沿next方向遍历
+        int index = nextIndex(maxIndex, size);
+        // 用"小找大"的方式统计所有可见山峰对
+        int res = 0;
+        // 遍历阶段开始，当index再次回到maxIndex的时候，说明转了一圈，遍历阶段就结束
+        while (index != maxIndex) {
+            // 当前数字arr[index] 要进桟， 判断会不会破坏第一维数字从顶到底一依次变大
+            // 如果破坏了，就依次弹出桟顶记录， 并计算山峰对数量
+            while (stack.peek().value < arr[index]) {
+                int k = stack.pop().times;
+                // 弹出记录为（X, K), 如果K == 1, 产生2对
+                // 如果K > 1,产生2*K + C（2， K)对
+                res += getInternalSumm(k) + (k << 1);
+            }
+            // 当前数字arr[index]要进桟了，如果和当前栈顶数字一样就合并
+            // 不一样就把记录（arr[index, 1]）放入桟中
+            if (stack.peek().value == arr[index]) {
+                stack.peek().times++;
+            } else {
+                stack.push(new Record(arr[index]));
+            }
+            index = nextIndex(index, size);
+        }
+
+        //清算阶段开始
+        // 清算阶段的第1小阶段
+        while (stack.size() > 2) {
+            int times = stack.pop().times;
+            res += getInternalSumm(times) + (times << 1);
+        }
+
+        // 清算第2小阶段
+        if (stack.size() == 2) {
+            int times = stack.pop().times;
+            res += getInternalSumm(times) + (stack.peek().times == 1 ? times : (times << 1));
+        }
+        // 清算第3小阶段
+        res += getInternalSumm(stack.pop().times);
+        return res;
+    }
+
+    /**
+     * 如果 k== 1，返回0； 如果k > 1, 返回C(2, K) (组合)
+     *
+     * @param k
+     * @return
+     */
+    private static int getInternalSumm(int k) {
+        return k == 1 ? 0 : (k * (k - 1) / 2);
+    }
+
+    /**
+     * 环形数组中当前位置为i,数组长度为size，返回i的下一个位置
+     *
+     * @param i
+     * @param size
+     * @return
+     */
+    private static int nextIndex(int i, int size) {
+        return i < (size - 1) ? (i + 1) : 0;
+    }
+}
+
Index: src/com/fan/crackingthecodinginterview/chap02/Num01.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.fan.crackingthecodinginterview.chap02;\n\nimport com.fan.util.ListNode;\n\n/**\n * @author : PF_23\n * @Description : Remove Dups: Write code to remove duplicates from an unsorted linked list.\n * @date : 2020/06/16.\n */\n\npublic class Num01 {\n    /**\n     * 使用递归删除重复的结点\n     *\n     * @param listNode 单链表\n     */\n\n    public static ListNode removeDups(ListNode listNode) {\n        if (listNode == null || listNode.next == null) {\n            return listNode;\n        }\n        ListNode next = listNode.next;\n        if (listNode.val == next.val) {\n            while (next != null && listNode.val == next.val) {\n                next = next.next;\n            }\n            return removeDups(next);\n        } else {\n            listNode.next = removeDups(next);\n            return listNode;\n        }\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/crackingthecodinginterview/chap02/Num01.java	(revision a3f26ab200a40cbc12a25ebc3cf30833210e36e0)
+++ src/com/fan/crackingthecodinginterview/chap02/Num01.java	(date 1593053872035)
@@ -30,5 +30,9 @@
             return listNode;
         }
     }
+
+    public static void main(String[] args) {
+        System.out.println("hhhh");
+    }
 }
 
Index: src/com/fan/zuoalgorithm/cha04/Num01PlusTwo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/Num01PlusTwo.java	(date 1593162276814)
+++ src/com/fan/zuoalgorithm/cha04/Num01PlusTwo.java	(date 1593162276814)
@@ -0,0 +1,65 @@
+package com.fan.zuoalgorithm.cha04;
+
+/**
+ * @author :  PF_23
+ * @Description : 母牛生产问题
+ * 母牛永远不会死
+ * @date : 2020/03/21.
+ */
+
+public class Num01PlusTwo {
+    public int c1(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n <= 3) {
+            return n;
+        }
+        return c1(n - 1) + c1(n - 3);
+    }
+
+    public int c2(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n <= 3) {
+            return n;
+        }
+        int pre1 = 1;
+        int pre2 = 2;
+        int res = 3;
+        // 两个临时变量用来存储pre1和pre2
+        int tmp1;
+        int tmp2;
+        for (int i = 4; i <= n; i++) {
+            tmp1 = res;
+            tmp2 = pre2;
+            res = res + pre1;
+            pre2 = tmp1;
+            pre1 = tmp2;
+        }
+        return res;
+    }
+
+    public int c3(int n) {
+        if (n < 1) {
+            return 0;
+        }
+        if (n <= 3) {
+            return n;
+        }
+
+        int[][] base = {{1, 1, 0}, {0, 0, 1}, {1, 0, 0}};
+        int[][] res = MatrixPowerUtil.matrixPower(base, n - 3);
+        // C(n) = （3，2，1）x res的第一个数，即矩阵（3，2，1）的第一行乘以矩阵res的第一列
+        return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
+    }
+
+
+    public static void main(String[] args) {
+        int n = 9;
+        int c2 = new Num01PlusTwo().c3(n);
+        System.out.println(c2);
+    }
+}
+
Index: src/com/fan/zuoalgorithm/cha04/EnvelopeComparator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/com/fan/zuoalgorithm/cha04/EnvelopeComparator.java	(date 1593162277105)
+++ src/com/fan/zuoalgorithm/cha04/EnvelopeComparator.java	(date 1593162277105)
@@ -0,0 +1,27 @@
+package com.fan.zuoalgorithm.cha04;
+
+import java.util.Arrays;
+import java.util.Comparator;
+
+/**
+ * @author :  PF_23
+ * @Description :
+ * @date : 2020/03/21.
+ */
+
+public class EnvelopeComparator implements Comparator<Envelope> {
+    @Override
+    public int compare(Envelope o1, Envelope o2) {
+        return o1.len != o2.len ? o1.len - o2.len : o2.wid - o1.wid;
+    }
+
+    public static Envelope[] getSortedEnvelopes(int[][] matrix) {
+        Envelope[] res = new Envelope[matrix.length];
+        for (int i = 0; i < matrix.length; i++) {
+            res[i] = new Envelope(matrix[i][0], matrix[i][1]);
+        }
+        Arrays.sort(res, new EnvelopeComparator());
+        return res;
+    }
+}
+
